{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Python","text":"<p>A particular but not private repository to centralize all studies about Python and a few famous Python's libraries. It's kind my own documentation about the language. </p>"},{"location":"#python-versions-supported","title":"Python Versions Supported","text":"<ul> <li>Python 3.11 or lower</li> </ul>"},{"location":"#backlog","title":"Backlog","text":"<ul> <li>Python 3.12 news</li> </ul>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>W3Schools - Python</li> <li>Fluent Python, 2nd Edition</li> <li>Python - Documentation</li> </ul> <p>*and of course chatGPT </p>"},{"location":"basics/python_paradigm/","title":"Python's Paradigms and Way of Work","text":"<p>It supports multiple programming paradigms and follows a specific way of working.Python's paradigms encompass dynamic typing, support for object-oriented and functional programming, garbage collection for memory management, emphasis on readability and expressiveness, and a rich standard library. These features contribute to Python's popularity and make it a flexible language for diverse programming needs. Here are some key aspects of Python's paradigms and its way of work:</p> <ul> <li> <p>Dynamic Typing System: Python uses a dynamic typing system, which means you don't need to explicitly declare variable types. You can assign values of different types to the same variable, and Python determines the type during runtime. This flexibility allows for quick prototyping and easy code modification.</p> </li> <li> <p>Object-Oriented Programming (OOP): Python fully supports object-oriented programming. It provides classes, objects, and inheritance, allowing you to create reusable and modular code. Encapsulation, polymorphism, and inheritance are core principles of OOP that Python encourages.</p> </li> <li> <p>Functional Programming: Python also supports functional programming paradigms. Functions are first-class citizens, which means you can assign them to variables, pass them as arguments, and return them as values. Python provides built-in higher-order functions like map, filter, and reduce, making it easier to write functional-style code.</p> </li> <li> <p>Imperative Programming: Python is primarily an imperative programming language. It follows a sequential execution model, where statements are executed in the order they appear. You can use control flow statements like if-else, loops, and switch-case to control the flow of execution.</p> </li> <li> <p>Garbage Collection: Python has an automatic garbage collector that manages memory allocation and deallocation. It frees developers from manual memory management tasks like allocating and releasing memory. The garbage collector identifies unused objects and reclaims the memory occupied by them, making Python memory-efficient.</p> </li> <li> <p>Extensive Standard Library: Python comes with a comprehensive standard library that offers a wide range of modules and functions for various purposes. The standard library provides ready-to-use solutions for common tasks, reducing the need for writing code from scratch. It enables developers to be productive and efficient.</p> </li> </ul>"},{"location":"basics/variables_and_datatypes/","title":"Variables and Data Types","text":"<p>In Python, variables can refer to different types of data, enabling us to manipulate that data as needed. To facilitate this, Python offers a range of standard data types that are specifically designed for storing and manipulating various kinds of data.</p>"},{"location":"basics/variables_and_datatypes/#variables","title":"Variables","text":"<p>One of the most notable and distinct features of variables in Python is their dynamic typing. This means that a single variable can change its type as required during the execution of the program.</p> variables.py<pre><code>&gt;&gt;&gt; nice_var = 123\n&gt;&gt;&gt; print(type(nice_var))\n&gt;&gt;&gt; nice_var = \"now I'm a string\"\n&gt;&gt;&gt; print(type(nice_var))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#data-types","title":"Data Types","text":"<p>Python categorizes data types into the following categories: Text, Numeric, Sequence, Mapping, Set, Boolean, and Binary types. These categories encompass the various types of data that Python can handle.</p>"},{"location":"basics/variables_and_datatypes/#text-type","title":"Text Type","text":"<ul> <li>str: Represents a sequence of characters, such as \"hello\" or \"Python\". Strings are immutable.</li> </ul> text.py<pre><code>&gt;&gt;&gt; string_var = \"Corinthians please help me\"\n&gt;&gt;&gt; print(string_var)\n&gt;&gt;&gt; print(type(string_var))\nCorinthians please help me\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#numeric-type","title":"Numeric Type","text":"<ul> <li>str: Represents integers (whole numbers) like 5, -3, 100.</li> <li>float: Represents floating-point numbers with decimal places like 3.14, -0.5, 2.0.</li> </ul> numeric.py<pre><code>&gt;&gt;&gt; int_number = 1910\n&gt;&gt;&gt; print(int_number)\n&gt;&gt;&gt; print(type(int_number))\n&gt;&gt;&gt; print(int_number + 2)\n&gt;&gt;&gt; float_number = int_number + 0.3\n&gt;&gt;&gt; print(float_number)\n&gt;&gt;&gt; print(type(float_number))\n1910\n&lt;class 'int'&gt;\n1912\n1910.3\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#sequence-type","title":"Sequence Type","text":"<ul> <li>list: Represents an ordered collection of elements enclosed in square brackets ([]). Lists can contain elements of different data types and are mutable, meaning you can modify them.</li> <li>tuple: Similar to lists, tuples represent an ordered collection of elements enclosed in parentheses (()). However, tuples are immutable, meaning they cannot be modified once created.</li> <li>range: Python provides a built-in range() function that generates a sequence of numbers within a specified range. The range() function is commonly used in loops and iterations.</li> </ul> sequence.py<pre><code>&gt;&gt;&gt; my_list = list([1, 2, 3, 4])\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; my_list = [5, 6, 7, 8]\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_tuple = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; my_tuple = tuple((1, 2, 3, 4, 5)) # cannot tuple(1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"Tuple with only one element\")\n&gt;&gt;&gt; my_tuple = (1,) # or tuple((1,))\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_range = range(1, 5)\n&gt;&gt;&gt; for num in my_range:\n&gt;&gt;&gt;     print(f\"num value: {num}\")\n[1, 2, 3, 4]\n&lt;class 'list'&gt;\n[5, 6, 7, 8]\n&lt;class 'list'&gt;\n---------------------------&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\nTuple with only one element\n(1,)\n&lt;class 'tuple'&gt;\n---------------------------&gt;\nnum value: 1\nnum value: 2\nnum value: 3\nnum value: 4\n</code></pre>"},{"location":"basics/variables_and_datatypes/#mapping-type","title":"Mapping Type","text":"<ul> <li>dictionary (dict): Represents a collection of key-value pairs enclosed in curly braces ({}) or created using the dict() constructor. Dictionaries provide a way to store and retrieve data using unique keys.</li> </ul> dict.py<pre><code>&gt;&gt;&gt; my_dict = {\"name\" : \"Gabriel\", \"age\" : 25}\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n&gt;&gt;&gt; my_dict = dict(name=\"Gabriel\", age=25)\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#set-data-types","title":"Set Data Types","text":"<ul> <li>set: Represents an unordered collection of unique elements enclosed in curly braces ({}) or created using the set() constructor. Sets are useful to perform operations like union, intersection, and difference.</li> <li>fronzenset: Similar to set, frozensets are immutable and represent an unordered collection of unique elements. While elements of a set can be modified at any time, elements of the frozen set remain the same after creation.</li> </ul> set.py<pre><code>&gt;&gt;&gt; my_set = set((\"apple\", \"banana\", \"cherry\"))\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; my_set = {5, 6, 7, 8}\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_frozenset = frozenset([1, 2, 3, 4, 5])\n&gt;&gt;&gt; print(my_frozenset)\n&gt;&gt;&gt; print(type(my_frozenset))\n{'banana', 'apple', 'cherry'}\n&lt;class 'set'&gt;\n{8, 5, 6, 7}\n&lt;class 'set'&gt;\n---------------------------&gt;\nfrozenset({1, 2, 3, 4, 5})\n&lt;class 'frozenset'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#boolean-type","title":"Boolean Type","text":"<ul> <li>boll: Represents a logical value indicating either True or False. Boolean values are often the result of comparisons or logical operations.</li> </ul> bool.py<pre><code>&gt;&gt;&gt; my_bool = bool(5)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = bool(0)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = True\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\nTrue\n&lt;class 'bool'&gt;\nFalse\n&lt;class 'bool'&gt;\nTrue\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#binary-types","title":"Binary Types","text":"<ul> <li>bytes: Bytes are immutable sequences of individual bytes. They represent a fixed sequence of bytes that cannot be modified once created. Bytes can be created using literals or by calling the built-in bytes() constructor. They are commonly used to store and process raw binary data.</li> <li>bytearray: Bytearray, unlike bytes, is a mutable sequence of bytes. It allows modifications after creation, such as appending, replacing, or deleting elements. Bytearray objects can be created using literals or by calling the bytearray() constructor. They provide a flexible way to modify binary data.</li> <li>memoryview: Memoryview is a Python object that provides a way to access the internal data of an object (such as bytes or bytearray) without making a copy. It acts as a \"window\" into the data, allowing efficient access and manipulation of large amounts of binary data. Memoryview objects can be created by calling the built-in memoryview() constructor.</li> </ul> binary.py<pre><code>&gt;&gt;&gt; my_bytes = b\"Hello\"\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; my_bytes = bytes(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = bytearray(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = memoryview(bytes(5))\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\nb'Hello'\n&lt;class 'bytes'&gt;\nb'\\x00\\x00\\x00\\x00\\x00'\n&lt;class 'bytes'&gt;\n---------------------------&gt;\nbytearray(b'\\x00\\x00\\x00\\x00\\x00')\n&lt;class 'bytearray'&gt;\n---------------------------&gt;\n&lt;memory at 0x7f53d774e800&gt;\n&lt;class 'memoryview'&gt;\n---------------------------&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#none-type","title":"None Type","text":"<ul> <li>None: Represents a special value indicating the absence of a value. It is commonly used to denote a variable that has not been assigned a value.</li> </ul> none.py<pre><code>&gt;&gt;&gt; my_none = None\n&gt;&gt;&gt; print(my_none)\n&gt;&gt;&gt; print(type(my_none))\nNone\n&lt;class 'NoneType'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#references","title":"References","text":"<ul> <li>W3Schools - Python Data Types</li> </ul>"},{"location":"data_model/","title":"Data Model","text":""}]}