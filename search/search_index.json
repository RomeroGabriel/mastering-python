{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Python","text":"<p>A particular but not private repository to centralize all studies about Python and a few famous Python's libraries. It's kind my own documentation about the language. </p>"},{"location":"#python-versions-supported","title":"Python Versions Supported","text":"<ul> <li>Python 3.11 or lower</li> </ul>"},{"location":"#backlog","title":"Backlog","text":"<ul> <li>Python 3.12 news</li> </ul>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>W3Schools - Python</li> <li>Fluent Python, 2nd Edition</li> <li>Python - Documentation</li> </ul> <p>*and of course chatGPT </p>"},{"location":"basics/control_flow/","title":"Control Flow","text":"<p>Listing the fundamental and commonly used control flow structures in Python.</p>"},{"location":"basics/control_flow/#if","title":"if","text":"if.py<pre><code>&gt;&gt;&gt; x = 42\n&gt;&gt;&gt; if x &lt; 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\nMore\n</code></pre>"},{"location":"basics/control_flow/#short-hand-if","title":"Short hand if","text":"short_if.py<pre><code>&gt;&gt;&gt; a = 25\n&gt;&gt;&gt; b = 15\n&gt;&gt;&gt; if a &gt; b: print(\"A is greater than B\")\n&gt;&gt;&gt; print(\"B\") if a &lt;= b else print(\"A\")\nA is greater than B\nA\n</code></pre>"},{"location":"basics/control_flow/#while","title":"while","text":"while.py<pre><code>&gt;&gt;&gt; n = 5\n&gt;&gt;&gt; while n &gt; 1:\n...     print(n)\n...     n = n - 1\n5\n4\n3\n2\n</code></pre>"},{"location":"basics/control_flow/#for","title":"for","text":"for.py<pre><code>&gt;&gt;&gt; words = ['cat', 'window', 'defenestrate']\n&gt;&gt;&gt; for w in words:\n...    print(w, len(w))\ncat 3\nwindow 6\ndefenestrate 12\n</code></pre>"},{"location":"basics/control_flow/#range","title":"range","text":"range.py<pre><code>&gt;&gt;&gt; for i in range(3):\n...    print(i)\n... print(\"range(3)---------&gt;\")\n&gt;&gt;&gt; for i in range(5, 10):\n...    print(i)\n... print(\"range(5, 10)---------&gt;\")\n&gt;&gt;&gt; for i in range(0, 10, 2):\n...    print(i)\n... print(\"range(0, 10, 2)---------&gt;\")\n&gt;&gt;&gt; a = ['Mary', 'had', 'a', 'little', 'lamb']\n&gt;&gt;&gt; for i in range(len(a)):\n...    print(i, a[i])\n... print(\"range(len(a))---------&gt;\")\n0\n1\n2\nrange(3)---------&gt;\n5\n6\n7\n8\n9\nrange(5, 10)---------&gt;\n0\n2\n4\n6\n8\nrange(0, 10, 2)---------&gt;\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\nrange(len(a))---------&gt;\n</code></pre>"},{"location":"basics/control_flow/#try","title":"try","text":"try.py<pre><code>&gt;&gt;&gt; try:\n...    zero_division = 10 / 0\n... except ZeroDivisionError as zero_error:\n...     print(f\"ERROR: {zero_error}\")\n... except:\n...     print(\"Global except clause\")\n... finally:\n...     print(\"Justing print the finally\")\nERROR: division by zero\nJusting print the finally\n</code></pre>"},{"location":"basics/control_flow/#break-continue-and-else-on-loops","title":"break, continue and else on loops","text":"<ul> <li>The break statement breaks out the innermost enclosing for or while loop.</li> <li>The else statement in loops is executed when the loop terminates through exhaustion, but not when the loop is terminated by a break statement.</li> </ul> break_else.py<pre><code>&gt;&gt;&gt; for n in range(2, 10):\n&gt;&gt;&gt;    for x in range(2, n):\n...        if n % x == 0:\n...            print(n, 'equals', x, '*', n//x)\n...            break\n...    else:\n...        # loop fell through without finding a factor\n...        print(n, 'is a prime number')\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n</code></pre> <ul> <li>The continue statement continues with the next iteration of the loop.</li> </ul> continue.py<pre><code>&gt;&gt;&gt; for num in range(2, 10):\n&gt;&gt;&gt;    if num % 2 == 0:\n...        print(\"Found an even number\", num)\n...        continue\n...    print(\"Found an odd number\", num)\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n</code></pre>"},{"location":"basics/control_flow/#match","title":"match","text":"<ul> <li>A match statement takes an exmpression and compares its value to sucessive patterns using the case blocks.</li> <li>This is similar to a switch statement but it's more similiar to patter matching.</li> <li>Only the first pattern that matches gets executed.</li> <li>There are many use cases that will be explorer more in this documentation.</li> </ul> match.py<pre><code>&gt;&gt;&gt; def http_error(status):\n&gt;&gt;&gt;    match status:\n...        case 400:\n...            return \"Bad request\"\n...        case 404:\n...            return \"Not found\"\n...        case 418:\n...            return \"I'm a teapot\"\n...        case _:\n...            return \"Something's wrong with the internet\"\n</code></pre>"},{"location":"basics/control_flow/#references","title":"References","text":"<ul> <li>Python - 8. Compound statements</li> <li>Python - 4. More Control Flow Tools</li> </ul>"},{"location":"basics/exception/","title":"Exception Handling","text":"<p>To ensure consistency and proper handling, all exceptions must be instances of a class that derives from the BaseException class. This principle helps maintain code clarity and enables developers to catch and respond to specific error scenarios effectively.</p>"},{"location":"basics/exception/#handiling-exceptions","title":"Handiling Exceptions","text":""},{"location":"basics/exception/#selected-exception","title":"Selected Exception","text":"selecet_exc.py<pre><code>&gt;&gt;&gt; try:\n...     x = \"hello\"\n...     y = sum(x)\n... except TypeError:\n...     print(\"Operation invalid\")\nOperation invalid\n</code></pre>"},{"location":"basics/exception/#multiple-handlers-expcetions","title":"Multiple Handlers Expcetions","text":"multi_selecet_exc.py<pre><code>&gt;&gt;&gt; try:\n...     x = \"hello\"\n...     z = x / 2\n...     y = sum(x)\n... except (ValueError, TypeError, NameError):\n...     print(\"Operation invalid\")\n...     print()\nOperation invalid\n</code></pre> multi_selecet_exc2.py<pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; try:\n...    f = open('myfile.txt')\n...    s = f.readline()\n...    i = int(s.strip())\n... except OSError as err:\n...    print(\"OS error: {0}\".format(err))\n... except ValueError:\n...    print(\"Could not convert data to an integer.\")\n... except BaseException as err:\n...    print(f\"Unexpected {err=}, {type(err)=}\")\n...    raise\nOS error: [Errno 2] No such file or directory: 'myfile.txt'\n</code></pre>"},{"location":"basics/exception/#baseexceptions-as-a-wildcard","title":"BaseExceptions as a Wildcard","text":"<p>By virtue of all exceptions inheriting from BaseException, it is possible to utilize the \"except\" statement to capture any exception.</p> base_exc.py<pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; try:\n...    f = open('myfile.txt')\n...    s = f.readline()\n...    i = int(s.strip())\n... except BaseException as err:\n...    print(f\"Unexpected {err=}, {type(err)=}\")\nUnexpected err=FileNotFoundError(2, 'No such file or directory'), type(err)=&lt;class 'FileNotFoundError'&gt;\n</code></pre>"},{"location":"basics/exception/#exception-properties-analyses","title":"Exception Properties Analyses","text":"base_exc.py<pre><code>&gt;&gt;&gt; try:\n...    raise Exception('spam', 'eggs')\n... except Exception as inst:\n...    print(type(inst))\n...    print(inst.args)\n...    x, y = inst.args\n...    print('x =', x)\n...    print('y =', y)\n&lt;class 'Exception'&gt;\n('spam', 'eggs')\nx = spam\ny = eggs\n</code></pre>"},{"location":"basics/exception/#raise-exceptions","title":"Raise Exceptions","text":"<pre><code>raise ValueError  # shorthand for 'raise ValueError()'\n</code></pre> <pre><code>try:\nraise NameError('Hi There')\nexcept NameError:\nprint('An exception flew by!')\nraise\n</code></pre>"},{"location":"basics/exception/#exceptions-chaining","title":"Exceptions Chaining","text":"<p>The raise statement in Python enables the option of chaining exceptions, facilitating error handling and flow control within the code.</p> exc_chaning.py<pre><code>&gt;&gt;&gt; def func():\n...    raise ConnectionError\n&gt;&gt;&gt; try:\n...    func()\n... except ConnectionError as exc:\n...    raise RuntimeError('Failed to open database') from exc\n</code></pre> exc_chaning_result.py<pre><code>Traceback (most recent call last):\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 4, in &lt;module&gt;\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"/home/gabriel/Projects/mastering-python/venv/lib/python3.11/site-packages/markdown_exec/formatters/python.py\", line 59, in _run_python\nexec(compiled, exec_globals)  # noqa: S102\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 6, in &lt;module&gt;\nraise RuntimeError('Failed to open database') from exc\nRuntimeError: Failed to open database\n</code></pre>"},{"location":"basics/exception/#user-definied-exceptions","title":"User-definied Exceptions","text":"<p>When creating user-defined exceptions, it is essential to ensure they are derived either directly or indirectly from the built-in Exception class. Conventionally, these custom exceptions are named with endings such as \"Error,\" following a clear and descriptive naming pattern for enhanced code readability.</p> db_exception.py<pre><code>from dataclasses import dataclass, field\n@dataclass\nclass DatabaseConnectionError(Exception):\nmessage: str = field(init=False, default=\"Couldn't connect to database\")\n</code></pre>"},{"location":"basics/exception/#references","title":"References","text":"<ul> <li>Python Exceptions</li> <li>Python Built-in Exceptions</li> <li>Real Python Exceptions</li> </ul>"},{"location":"basics/modules_packages/","title":"Modules and Packages","text":""},{"location":"basics/modules_packages/#modules","title":"Modules","text":"<p>In Python, a module is essentially a file that contains various definitions and statements. The module name corresponds to the file name without the .py extension. Within a module, the module's name (as a string) is available as the value of the global variable <code>__name__</code>.</p> <p>When importing modules, if the imported module names are placed at the top level of a file (outside any function or class), they are added to the module's global namespace. This allows easy access to the functions, variables, or classes defined within the imported modules.</p> <p>In addition to Python-written modules, you can also define a folder as a module by including a file called init.py within it. This folder then becomes a module that can be imported and utilized.</p> modules.py<pre><code># import module 'dataclasses' to current namespaces\nimport dataclasses\n# import names (dataclass, field) to current namespaces\nfrom dataclasses import dataclass, field \n# import all names from the module,\n# except those beginning with underscore on the name\nfrom dataclasses import *\n</code></pre>"},{"location":"basics/modules_packages/#absolute-imports","title":"Absolute imports","text":"<p>An absolute import refers to a type of import where the location of the classes being imported is fully specified. This allows for a clear and unambiguous reference to the desired import location, ensuring that there is no confusion or conflict with other modules or classes that may have the same name but reside in different packages or directories.</p> abs_import.py<pre><code># from PACKAGE.MODULE.MODULE import CLASS\nfrom pandas.core.frame import DataFrame\n# import PACKAGE.MODULE.MODULE\nimport pandas.core.frame as frame\nexample = frame.DataFrame()\n# from PACKAGE.MODULE import MODULE \nfrom pandas.core import frame\n</code></pre>"},{"location":"basics/modules_packages/#relative-imports","title":"Relative imports","text":"<p>Relative imports allow us to specify the location of the classes being imported relative to the current package or module. By using relative import statements, we can reference and import classes from modules located within the same package or subpackages, providing a concise and context-aware way to import and utilize code within the project's structure.</p> <ul> <li>Current directory: <code>.</code></li> <li>Previous directory: <code>..</code></li> </ul> <pre>\n\u2514\u2500\u2500 not_nice_import.py\n    \u251c\u2500\u2500 relative_import.py\n    \u251c\u2500\u2500 nice_file.py\n</pre> relative_import.py<pre><code># if the files are in the same place\nfrom .nice_file import add_func\n# if the file calling is one directory down\nfrom ..not_nice_import import not_nice_add_func\n</code></pre>"},{"location":"basics/modules_packages/#impact-of-init-file","title":"Impact of init file","text":"<pre>\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 calculator_func\n        \u251c\u2500\u2500 __init_.py\n        \u251c\u2500\u2500 add_func.py\n        \u251c\u2500\u2500 sub_func.py\n        \u251c\u2500\u2500 mul_func.py\n        \u251c\u2500\u2500 div_func.py\n    \u251c\u2500\u2500 calculator.py\n</pre> __init__.py<pre><code>from .add_func import add_func\nfrom .sub_func import sub_func\nfrom .mul_func import mul_func\nfrom .div_func import div_func\n</code></pre> calculator.py<pre><code># instead of\nfrom calculator_func.add_func import add_func\nfrom calculator_func.sub_func import sub_func\n# possible to import\nfrom calculator_func import add_func, sub_func, mul_func, div_func\n</code></pre>"},{"location":"basics/modules_packages/#executing-modules-as-scripts","title":"Executing modules as scripts","text":"<p>In Python, any file that contains a module is also considered a Python script and can be executed when imported. However, by including the following code block, it prevents the module from executing when imported, allowing the file to be used both as a standalone script and as an importable module:</p> import_main.py<pre><code>if __name__ == \"__main__\":\n# Code to be executed when the script is run directly\npass\n</code></pre> <p>This usage of the <code>__name__</code> variable ensures that the code block under the if statement is only executed when the file is run directly as a script, rather than being imported as a module. This distinction allows the file to serve dual purposes, functioning as an executable script or an importable module based on how it is invoked.</p>"},{"location":"basics/modules_packages/#packages","title":"Packages","text":"<p>In Python, a package is a collection of modules that enables hierarchical structuring of the module namespace using dot notation. They help prevent naming collisions between modules by providing a way to create a nested structure for modules. Similar to how modules mitigate conflicts in global variable names, packages ensure that module names remain distinct and avoid clashes within the project's namespace. This hierarchical organization enhances code readability, maintainability, and reduces the risk of naming conflicts.</p>"},{"location":"basics/modules_packages/#difference-when-use-from-and-import","title":"Difference when use <code>from</code> and <code>import</code>","text":"from_import.py<pre><code># item can be either a submodule, or some other name defined in the package,\n# like a function, class or variable\nfrom package import item\n# item MUST BE a package. subitem can be a module or a package\n# but can't be a class or function\nimport package.item.subitem\n</code></pre>"},{"location":"basics/modules_packages/#importing-from-a-package","title":"Importing * from a Package","text":"<p>Importing everything using the <code>*</code> notation in Python packages can lead to lengthy import times and unintended side effects. It is generally not recommended to import all modules from a package in this manner. However, you can specify which modules should be imported when using <code>from package import *</code>, you can define a list named <code>__all__</code> in the <code>__init__</code>.py file of the package.</p> __init__with_all.py<pre><code>from .add_func import add_func\nfrom .sub_func import sub_func\nfrom .mul_func import mul_func\nfrom .div_func import div_func\n__all__ = [\n\"add_func\",\n\"sub_func\",\n\"mul_func\",\n\"div_func\",\n]\n</code></pre>"},{"location":"basics/modules_packages/#references","title":"References","text":"<ul> <li>Python Modules doc</li> <li>Real Python Modules and Packages</li> </ul>"},{"location":"basics/object_handling/","title":"Object References, Mutability, and Recycling","text":""},{"location":"basics/object_handling/#variables-references","title":"Variables references","text":"<p>In Python, variables serve as labels that refer to objects stored in memory. It's important to understand that an object can have multiple labels assigned to it, creating a form of aliasing. Instead of saying that an object is assigned to a variable, it is more accurate and meaningful to say that a variable is assigned to an object. This shift in perspective acknowledges that the object exists before the assignment takes place, clarifying the relationship between variables and objects.</p> <p>If a variable changes the value of an object, all other variables assigned to the same object will reflect that change as well.</p> var_ref.py<pre><code>&gt;&gt;&gt; a = [1, 2, 3] \n&gt;&gt;&gt; b = a          \n&gt;&gt;&gt; a.append(4)    \n&gt;&gt;&gt; print(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n</code></pre> <p></p>"},{"location":"basics/object_handling/#identity-and-equality","title":"Identity and Equality","text":"<p>In Python, variables that refer to the same object have the same identity and values. Any changes made to the object through one variable will be reflected when accessing it through the other variable.</p> <p>On the other hand, if two different objects are created with the same values, they will have different identities. This is because each object occupies a distinct location in memory, even though their values may be the same. It's important to note that equality of values does not imply identity. Each object has its own unique identity, regardless of the similarity of their values.</p> identity_equality.py<pre><code>&gt;&gt;&gt; charles = {'name': 'Charles L. Dodgson', 'born': 1832}\n&gt;&gt;&gt; lewis = charles  \n&gt;&gt;&gt; print(f\"Lewis is charles? {lewis is charles}\")\n&gt;&gt;&gt; print(f\"Charles id: {id(charles)}, Lewis id: {id(lewis)}\")\n&gt;&gt;&gt; lewis['balance'] = 950  \n&gt;&gt;&gt; print(f\"Charles with balance property also {charles}\")\n&gt;&gt;&gt; alex = {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}\n&gt;&gt;&gt; print(f\"Alex == Charles? {alex == charles}\")\n&gt;&gt;&gt; print(f\"Alex is Charles? {alex is charles}\")\nLewis is charles? True\nCharles id: 139845029100992, Lewis id: 139845029100992\nCharles with balance property also {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}\nAlex == Charles? True\nAlex is Charles? False\n</code></pre>"},{"location":"basics/object_handling/#choosing-between-and-is","title":"Choosing between <code>==</code> and <code>is</code>","text":"<p>In Python, the == operator is used to compare the values of objects, evaluating whether they hold the same data. On the other hand, the is operator compares the identities of objects, determining if they refer to the same underlying object in memory.</p> <p>The is operator is generally faster than == because it cannot be overloaded. Since it is not subject to method invocations, Python can directly compare the integer IDs of the objects, making the evaluation process straightforward and efficient. In contrast, when using the == operator, Python invokes the <code>__eq__()</code> special method to compare the values of objects. This syntactic sugar allows for more flexible value comparisons and supports custom equality behavior defined by the objects' classes.</p>"},{"location":"basics/object_handling/#copying-objects","title":"Copying objects","text":"<p>In Python, there are two types of object copying: deep copy and shallow copy.</p> <p>A deep copy creates a completely independent duplicate of an object, including any nested objects it may contain. This means that the duplicate object and its nested objects do not share any references with the original object. Any modifications made to the duplicate will not affect the original object or its nested objects.</p> <p>On the other hand, a shallow copy creates a new object that shares some references with the original object. It essentially creates a new object with a separate identity, but certain internal references are still shared. This means that changes made to the shallow copy may impact the original object or its nested objects, as they are still connected through shared references.</p> <p>By default, Python performs shallow copies when creating copies of objects. However, it's important to note that some built-in data types, such as numbers and strings, are immutable, and creating copies of them behaves like a deep copy, as there are no nested mutable objects to share references with.</p> copy.py<pre><code>&gt;&gt;&gt; l1 = [3, [66, 55, 44], (7, 8, 9)]\n&gt;&gt;&gt; l2 = list(l1)\n&gt;&gt;&gt; print(f\"l1 == l2? {l1 == l2}\")\n&gt;&gt;&gt; print(f\"l1 is l2? {l1 is l2}\")\n&gt;&gt;&gt; print(f\"l1 id: {id(l1)}, l2 id: {id(l2)}\")\n&gt;&gt;&gt; l1.append(100)\n&gt;&gt;&gt; print(\"You can change l1 just fine, without changing l2: \")\n&gt;&gt;&gt; print(l1)\n&gt;&gt;&gt; print(l2)\n&gt;&gt;&gt; print(\"However, when you change l1[1], and l2[1] which is a list and mutable\")\n&gt;&gt;&gt; l1[1].remove(55)   \n&gt;&gt;&gt; l2[1] += [33, 22]  \n&gt;&gt;&gt; l2[2] += (10, 11)\n&gt;&gt;&gt; print(l1)\n&gt;&gt;&gt; print(l2)\nl1 == l2? True\nl1 is l2? False\nl1 id: 139845030371136, l2 id: 139845044443456\nYou can change l1 just fine, without changing l2: \n[3, [66, 55, 44], (7, 8, 9), 100]\n[3, [66, 55, 44], (7, 8, 9)]\nHowever, when you change l1[1], and l2[1] which is a list and mutable\n[3, [66, 44, 33, 22], (7, 8, 9), 100]\n[3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]\n</code></pre> <p>In Python, you have the ability to customize the behavior of copying objects by implementing the <code>__copy__()</code> and <code>__deepcopy__()</code> special methods.</p> <p>The <code>__copy__()</code> method allows you to define how an object should be shallow copied. By overriding this method in your class, you can specify the exact behavior you desire when creating a shallow copy of an instance. Similarly, the <code>__deepcopy__()</code> method allows you to define the behavior for deep copying an object. By implementing this method, you can control how the object and its nested objects should be duplicated to create an independent deep copy.</p>"},{"location":"basics/object_handling/#command-del-and-garbage-collection","title":"Command <code>del</code> and Garbage Collection","text":"<p>Objects\u00a0are never explicitly destroyed; however, when they become unreachable they may be garbage-collected.</p> <p>The <code>del</code>\u00a0is that it\u2019s not a function, it\u2019s a statement. del\u00a0deletes references, not objects. Python\u2019s garbage collector may discard an object from memory as an indirect result of\u00a0del, if the deleted variable was the last reference to the object. In CPython, the primary algorithm for garbage collection is\u00a0reference counting.</p> del.py<pre><code>&gt;&gt;&gt; a = [1, 2]  \n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; print(id(a), id(b))\n&gt;&gt;&gt; del a\n&gt;&gt;&gt; print(b)\n&gt;&gt;&gt; print(\"Rebinding b to a different object, removing the last remaining reference to [1, 2]\")\n&gt;&gt;&gt; b = [3]\n&gt;&gt;&gt; print(id(b))\n&gt;&gt;&gt; print(\"Now the garbage collector can discard that object.\")\n139845028592960 139845028592960\n[1, 2]\nRebinding b to a different object, removing the last remaining reference to [1, 2]\n139845029092288\nNow the garbage collector can discard that object.\n</code></pre>"},{"location":"basics/object_handling/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"basics/operators/","title":"Python Operators","text":""},{"location":"basics/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li>Addition: +</li> <li>Subtraction: -</li> <li>Multiplication: *</li> <li>Division: /</li> <li>Floor Division: //</li> <li>Modulus: %</li> <li>Exponentiation: **</li> </ul> arith_operators.py<pre><code>&gt;&gt;&gt; addition = 123 + 123\n&gt;&gt;&gt; subtraction = 123 - 123\n&gt;&gt;&gt; multi = 123 * 123\n&gt;&gt;&gt; division = 123 / 123\n&gt;&gt;&gt; floor_division = 25 // 5\n&gt;&gt;&gt; print(f\"floor_division by 25/5: {floor_division}\")\n&gt;&gt;&gt; floor_division = 25 // 6\n&gt;&gt;&gt; print(f\"floor_division by 25/6: {floor_division}\")\n&gt;&gt;&gt; modulus = 25 % 5\n&gt;&gt;&gt; print(f\"modulus by 25/5: {modulus}\")\n&gt;&gt;&gt; modulus = 25 % 6\n&gt;&gt;&gt; print(f\"modulus by 25/6: {modulus}\")\n&gt;&gt;&gt; exponentiation = 2 ** 2\n&gt;&gt;&gt; print(f\"exponentiation: {exponentiation}\")\nfloor_division by 25/5: 5\nfloor_division by 25/6: 4\nmodulus by 25/5: 0\nmodulus by 25/6: 1\nexponentiation: 4\n</code></pre>"},{"location":"basics/operators/#assignment-operators","title":"Assignment Operators","text":"<ul> <li>Assignment: =</li> <li>Addition Assignment: +=</li> <li>Subtraction Assignment: -=</li> <li>Multiplication Assignment: *=</li> <li>Division Assignment: /=</li> <li>Floor Division Assignment: //=</li> <li>Modulus Assignment: %=</li> <li>Exponentiation Assignment: **=</li> </ul>"},{"location":"basics/operators/#comparison-operators","title":"Comparison Operators","text":"<ul> <li>Equal to: ==</li> <li>Not equal to: !=</li> <li>Greater than: &gt;</li> <li>Less than: &lt;</li> <li>Greater than or equal to: &gt;=</li> <li>Less than or equal to: &lt;=</li> </ul>"},{"location":"basics/operators/#logical-operators","title":"Logical Operators","text":"<ul> <li>Logical AND: and</li> <li>Logical OR: or</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>Bitwise operators are used to perform operations on individual bits of binary numbers. They treat numbers as sequences of binary digits (bits) and operate on them bit by bit.</p> <ul> <li> <p>Bitwise AND: &amp;</p> <p>Performs a logical AND operation on each pair of corresponding bits. If both bits are 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise OR: |</p> <p>Performs a logical OR operation on each pair of corresponding bits. If at least one bit is 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise XOR: ^</p> <p>Performs a logical XOR (exclusive OR) operation on each pair of corresponding bits. If the two bits are different (one is 0 and the other is 1), the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise NOT: ~</p> <p>Inverts (flips) the bits of a number. Changes each 1 to 0 and each 0 to 1.</p> </li> <li> <p>Left Shift: &lt;&lt;</p> <p>Shifts the bits of a number to the left by a specified number of positions. The empty positions on the right are filled with zeros. Each shift to the left is equivalent to multiplying the number by 2.</p> </li> <li> <p>Right Shift: &gt;&gt;</p> <p>Shifts the bits of a number to the right by a specified number of positions. The empty positions on the left are filled with the sign bit (0 for positive numbers, 1 for negative numbers). Each arithmetic shift to the right is equivalent to dividing the number by 2.</p> </li> </ul> <p>Bitwise operators are commonly used in low-level programming, networking, and manipulation of binary data. They allow you to manipulate individual bits within numbers, set or clear specific flags, or extract information from bit patterns.</p>"},{"location":"basics/operators/#membership-operators","title":"Membership Operators","text":"<ul> <li>In: in</li> <li>Not in: not in</li> </ul>"},{"location":"basics/operators/#identity-operators","title":"Identity Operators","text":"<ul> <li>Is: is</li> <li>Is not: is not</li> </ul>"},{"location":"basics/operators/#unary-operators","title":"Unary Operators","text":"<ul> <li>Positive: +</li> <li>Negative: -</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#ternary-operator","title":"Ternary Operator","text":"<ul> <li>Conditional Expression: a if condition else b</li> </ul> ternary.py<pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 20\n&gt;&gt;&gt; print(a if a &gt; b else b)\n20\n</code></pre>"},{"location":"basics/python_paradigm/","title":"Python's Paradigms and Way of Work","text":"<p>It supports multiple programming paradigms and follows a specific way of working.Python's paradigms encompass dynamic typing, support for object-oriented and functional programming, garbage collection for memory management, emphasis on readability and expressiveness, and a rich standard library. These features contribute to Python's popularity and make it a flexible language for diverse programming needs. Here are some key aspects of Python's paradigms and its way of work:</p> <ul> <li> <p>Dynamic Typing System: Python uses a dynamic typing system, which means you don't need to explicitly declare variable types. You can assign values of different types to the same variable, and Python determines the type during runtime. This flexibility allows for quick prototyping and easy code modification.</p> </li> <li> <p>Object-Oriented Programming (OOP): Python fully supports object-oriented programming. It provides classes, objects, and inheritance, allowing you to create reusable and modular code. Encapsulation, polymorphism, and inheritance are core principles of OOP that Python encourages.</p> </li> <li> <p>Functional Programming: Python also supports functional programming paradigms. Functions are first-class citizens, which means you can assign them to variables, pass them as arguments, and return them as values. Python provides built-in higher-order functions like map, filter, and reduce, making it easier to write functional-style code.</p> </li> <li> <p>Imperative Programming: Python is primarily an imperative programming language. It follows a sequential execution model, where statements are executed in the order they appear. You can use control flow statements like if-else, loops, and switch-case to control the flow of execution.</p> </li> <li> <p>Garbage Collection: Python has an automatic garbage collector that manages memory allocation and deallocation. It frees developers from manual memory management tasks like allocating and releasing memory. The garbage collector identifies unused objects and reclaims the memory occupied by them, making Python memory-efficient.</p> </li> <li> <p>Extensive Standard Library: Python comes with a comprehensive standard library that offers a wide range of modules and functions for various purposes. The standard library provides ready-to-use solutions for common tasks, reducing the need for writing code from scratch. It enables developers to be productive and efficient.</p> </li> </ul>"},{"location":"basics/variables_and_datatypes/","title":"Variables and Data Types","text":"<p>In Python, variables can refer to different types of data, enabling us to manipulate that data as needed. To facilitate this, Python offers a range of standard data types that are specifically designed for storing and manipulating various kinds of data.</p>"},{"location":"basics/variables_and_datatypes/#variables","title":"Variables","text":"<p>One of the most notable and distinct features of variables in Python is their dynamic typing. This means that a single variable can change its type as required during the execution of the program.</p> variables.py<pre><code>&gt;&gt;&gt; nice_var = 123\n&gt;&gt;&gt; print(type(nice_var))\n&gt;&gt;&gt; nice_var = \"now I'm a string\"\n&gt;&gt;&gt; print(type(nice_var))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#data-types","title":"Data Types","text":"<p>Python categorizes data types into the following categories: Text, Numeric, Sequence, Mapping, Set, Boolean, and Binary types. These categories encompass the various types of data that Python can handle.</p>"},{"location":"basics/variables_and_datatypes/#text-type","title":"Text Type","text":"<ul> <li>str: Represents a sequence of characters, such as \"hello\" or \"Python\". Strings are immutable.</li> </ul> text.py<pre><code>&gt;&gt;&gt; string_var = \"Corinthians please help me\"\n&gt;&gt;&gt; print(string_var)\n&gt;&gt;&gt; print(type(string_var))\nCorinthians please help me\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#numeric-type","title":"Numeric Type","text":"<ul> <li>str: Represents integers (whole numbers) like 5, -3, 100.</li> <li>float: Represents floating-point numbers with decimal places like 3.14, -0.5, 2.0.</li> </ul> numeric.py<pre><code>&gt;&gt;&gt; int_number = 1910\n&gt;&gt;&gt; print(int_number)\n&gt;&gt;&gt; print(type(int_number))\n&gt;&gt;&gt; print(int_number + 2)\n&gt;&gt;&gt; float_number = int_number + 0.3\n&gt;&gt;&gt; print(float_number)\n&gt;&gt;&gt; print(type(float_number))\n1910\n&lt;class 'int'&gt;\n1912\n1910.3\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#sequence-type","title":"Sequence Type","text":"<ul> <li>list: Represents an ordered collection of elements enclosed in square brackets ([]). Lists can contain elements of different data types and are mutable, meaning you can modify them.</li> <li>tuple: Similar to lists, tuples represent an ordered collection of elements enclosed in parentheses (()). However, tuples are immutable, meaning they cannot be modified once created.</li> <li>range: Python provides a built-in range() function that generates a sequence of numbers within a specified range. The range() function is commonly used in loops and iterations.</li> </ul> sequence.py<pre><code>&gt;&gt;&gt; my_list = list([1, 2, 3, 4])\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; my_list = [5, 6, 7, 8]\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_tuple = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; my_tuple = tuple((1, 2, 3, 4, 5)) # cannot tuple(1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"Tuple with only one element\")\n&gt;&gt;&gt; my_tuple = (1,) # or tuple((1,))\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_range = range(1, 5)\n&gt;&gt;&gt; for num in my_range:\n&gt;&gt;&gt;     print(f\"num value: {num}\")\n[1, 2, 3, 4]\n&lt;class 'list'&gt;\n[5, 6, 7, 8]\n&lt;class 'list'&gt;\n---------------------------&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\nTuple with only one element\n(1,)\n&lt;class 'tuple'&gt;\n---------------------------&gt;\nnum value: 1\nnum value: 2\nnum value: 3\nnum value: 4\n</code></pre>"},{"location":"basics/variables_and_datatypes/#mapping-type","title":"Mapping Type","text":"<ul> <li>dictionary (dict): Represents a collection of key-value pairs enclosed in curly braces ({}) or created using the dict() constructor. Dictionaries provide a way to store and retrieve data using unique keys.</li> </ul> dict.py<pre><code>&gt;&gt;&gt; my_dict = {\"name\" : \"Gabriel\", \"age\" : 25}\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n&gt;&gt;&gt; my_dict = dict(name=\"Gabriel\", age=25)\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#set-data-types","title":"Set Data Types","text":"<ul> <li>set: Represents an unordered collection of unique elements enclosed in curly braces ({}) or created using the set() constructor. Sets are useful to perform operations like union, intersection, and difference.</li> <li>fronzenset: Similar to set, frozensets are immutable and represent an unordered collection of unique elements. While elements of a set can be modified at any time, elements of the frozen set remain the same after creation.</li> </ul> set.py<pre><code>&gt;&gt;&gt; my_set = set((\"apple\", \"banana\", \"cherry\"))\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; my_set = {5, 6, 7, 8}\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_frozenset = frozenset([1, 2, 3, 4, 5])\n&gt;&gt;&gt; print(my_frozenset)\n&gt;&gt;&gt; print(type(my_frozenset))\n{'apple', 'cherry', 'banana'}\n&lt;class 'set'&gt;\n{8, 5, 6, 7}\n&lt;class 'set'&gt;\n---------------------------&gt;\nfrozenset({1, 2, 3, 4, 5})\n&lt;class 'frozenset'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#boolean-type","title":"Boolean Type","text":"<ul> <li>boll: Represents a logical value indicating either True or False. Boolean values are often the result of comparisons or logical operations.</li> </ul> bool.py<pre><code>&gt;&gt;&gt; my_bool = bool(5)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = bool(0)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = True\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\nTrue\n&lt;class 'bool'&gt;\nFalse\n&lt;class 'bool'&gt;\nTrue\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#binary-types","title":"Binary Types","text":"<ul> <li>bytes: Bytes are immutable sequences of individual bytes. They represent a fixed sequence of bytes that cannot be modified once created. Bytes can be created using literals or by calling the built-in bytes() constructor. They are commonly used to store and process raw binary data.</li> <li>bytearray: Bytearray, unlike bytes, is a mutable sequence of bytes. It allows modifications after creation, such as appending, replacing, or deleting elements. Bytearray objects can be created using literals or by calling the bytearray() constructor. They provide a flexible way to modify binary data.</li> <li>memoryview: Memoryview is a Python object that provides a way to access the internal data of an object (such as bytes or bytearray) without making a copy. It acts as a \"window\" into the data, allowing efficient access and manipulation of large amounts of binary data. Memoryview objects can be created by calling the built-in memoryview() constructor.</li> </ul> binary.py<pre><code>&gt;&gt;&gt; my_bytes = b\"Hello\"\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; my_bytes = bytes(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = bytearray(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = memoryview(bytes(5))\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\nb'Hello'\n&lt;class 'bytes'&gt;\nb'\\x00\\x00\\x00\\x00\\x00'\n&lt;class 'bytes'&gt;\n---------------------------&gt;\nbytearray(b'\\x00\\x00\\x00\\x00\\x00')\n&lt;class 'bytearray'&gt;\n---------------------------&gt;\n&lt;memory at 0x7f30354be980&gt;\n&lt;class 'memoryview'&gt;\n---------------------------&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#none-type","title":"None Type","text":"<ul> <li>None: Represents a special value indicating the absence of a value. It is commonly used to denote a variable that has not been assigned a value.</li> </ul> none.py<pre><code>&gt;&gt;&gt; my_none = None\n&gt;&gt;&gt; print(my_none)\n&gt;&gt;&gt; print(type(my_none))\nNone\n&lt;class 'NoneType'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#references","title":"References","text":"<ul> <li>W3Schools - Python Data Types</li> </ul>"},{"location":"data_model/","title":"Data Model","text":""},{"location":"data_structures/list/","title":"List","text":"<p>A list is a built-in data structure in Python and is classified as a type of sequence data structure.</p>"},{"location":"data_structures/list/#characteristics","title":"Characteristics","text":"<ol> <li>Mutable Sequence</li> <li>Container Sequence</li> <li>Use square brackets []</li> </ol>"},{"location":"data_structures/list/#list-comprehensions","title":"List Comprehensions","text":"<p>List comprehensions provide a concise method for <code>creating lists</code>. Generator expressions for other kinds of sequences. They are commonly used to generate new lists by <code>applying operations to elements of an existing sequence or iterable</code>, or to create a sublist of elements that fulfill specific conditions.Using list comprehensions can significantly <code>enhance the readability of your code</code>.</p> <p>A list comprehension consists of <code>brackets</code> containing an expression followed by a <code>for clause, then zero or more for or if clauses</code>. The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it.</p>"},{"location":"data_structures/list/#examples","title":"Examples","text":"listcomp.py<pre><code>&gt;&gt;&gt; print(\"comparison with map function\")\n&gt;&gt;&gt; squares = list(map(lambda x: x**2, range(10)))\n&gt;&gt;&gt; print(f\"squares =&gt; {squares}\")\n&gt;&gt;&gt; squares = [x**2 for x in range(10)]\n&gt;&gt;&gt; print(f\"squares =&gt; {squares}\")\n&gt;&gt;&gt; print(\"comparison with filter function\")\n&gt;&gt;&gt; symbols = '$\u00a2\u00a3\u00a5\u20ac\u00a4'\n&gt;&gt;&gt; beyond_ascii = list(filter(lambda c: c &gt; 127, map(ord, symbols)))\n&gt;&gt;&gt; print(f\"beyond_ascii =&gt; {beyond_ascii}\")\n&gt;&gt;&gt; beyond_ascii = [ord(s) for s in symbols if ord(s) &gt; 127]\n&gt;&gt;&gt; print(f\"beyond_ascii =&gt; {beyond_ascii}\")\n&gt;&gt;&gt; print(\"Multiple listcomp\")\n&gt;&gt;&gt; combs = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n&gt;&gt;&gt; print(combs)\n&gt;&gt;&gt; combs = []\n&gt;&gt;&gt; for x in [1,2,3]:\n...     for y in [3,1,4]:\n...         if x != y:\n...             combs.append((x, y))\n&gt;&gt;&gt; print(combs)\ncomparison with map function\nsquares =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nsquares =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\ncomparison with filter function\nbeyond_ascii =&gt; [162, 163, 165, 8364, 164]\nbeyond_ascii =&gt; [162, 163, 165, 8364, 164]\nMultiple listcomp\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n</code></pre>"},{"location":"data_structures/list/#listsort-x-sorted-build-in","title":"list.sort x sorted Build-In","text":"<ol> <li>The list.sort method sorts a list in place (<code>without making a copy</code>):<ol> <li>It returns None - This follows an <code>important Python API convention: functions or methods that change an object in place should return None to make it clear to the caller</code>.</li> <li>We cannot chain calls to these methods.</li> </ol> </li> <li>The sorted function <code>creates a new list and returns it</code>:<ol> <li>It accepts any iterable object as an argument.</li> <li>It always returns a newly created list.</li> </ol> </li> <li>Both methods take two optional keyword-only arguments:<ol> <li><code>reverse</code>: If True, the items are returned in descending order. The default is False.</li> <li><code>key</code>: A one-argument function to be applied to each item.</li> </ol> </li> </ol> gen_enx.py<pre><code>&gt;&gt;&gt; fruits = ['grape', 'raspberry', 'apple', 'banana']\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits)}, fruits: {fruits}\")\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits, reverse=True)}, fruits: {fruits}\")\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits, key=len)}, fruits: {fruits}\")\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits, key=len, reverse=True)}, fruits: {fruits}\")\n&gt;&gt;&gt; fruits.sort()\n&gt;&gt;&gt; print(f\"Now fruits changed: {fruits}\")\nsorted: ['apple', 'banana', 'grape', 'raspberry'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nsorted: ['raspberry', 'grape', 'banana', 'apple'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nsorted: ['grape', 'apple', 'banana', 'raspberry'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nsorted: ['raspberry', 'banana', 'grape', 'apple'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nNow fruits changed: ['apple', 'banana', 'grape', 'raspberry']\n</code></pre>"},{"location":"data_structures/list/#when-a-list-is-not-the-answer","title":"When a List is not the answer","text":"<ol> <li>An <code>array</code> saves a lot of memory when you need to handle millions of floating-point;</li> <li>A <code>deque</code> (double-ended queue) is more efficient <code>FIFO</code> (First-In First-out) data structure;</li> <li><code>Sets</code> are optimized for <code>fast membership checking</code>.</li> </ol>"},{"location":"data_structures/list/#extras","title":"Extras","text":"<ol> <li>Methods for lists</li> <li>Using Lists as Stacks</li> <li>Using Lists as Queues</li> </ol>"},{"location":"data_structures/list/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Python - More on List</li> </ul>"},{"location":"data_structures/sequence/","title":"Built-In Sequences","text":"<p>Python provides various built-in sequence types implemented in C, offering a rich set of functionalities through their APIs. These sequences include lists, tuples, strings, and range objects, each with its own unique features and use cases.</p>"},{"location":"data_structures/sequence/#classificationstypes-of-sequences","title":"Classifications/Types of Sequences","text":""},{"location":"data_structures/sequence/#container-x-flat","title":"Container x Flat","text":"<p>Container sequences, such as lists, tuples, and collections.deque, <code>can hold items of different types</code>, including other nested containers. They <code>hold references to the objects they contain</code>, which may be of any type.</p> <p>On the other hand, flat sequences, like str, bytes, and array.array, <code>hold items of one simple type and store the value of their contents in their own memory space</code>, not as separate Python objects. Refer to the image below for more details.</p> <p></p> <p>Container x Flat. Image from Fluent Python, 2nd Edition</p>"},{"location":"data_structures/sequence/#mutable-x-immutable","title":"Mutable x Immutable","text":"<p>Mutable sequences include list, bytearray, array.array, and collections.deque. These sequences <code>can be modified after creation</code>, allowing you to add, remove, or modify elements.</p> <p>Immutable sequences include tuple, str, and bytes. Once created, these sequences <code>cannot be changed</code>, meaning their elements cannot be modified or added.</p> <p><code>Mutable sequences inherit all methods from immutable sequences</code> and also implement several additional methods. Refer to the image below for more details.</p> <p></p> <p>Mutable Inherit. Image from Fluent Python, 2nd Edition</p>"},{"location":"data_structures/sequence/#unpacking","title":"Unpacking","text":"<p>Sequence unpacking in Python allows you to <code>extract elements from a sequence without using indexes</code>. It avoids unnecessary and error-prone index-based extraction. This feature <code>works with any iterable object</code>, including iterators that don't support index notation (using []). Instead of accessing elements by index, you can assign them directly to variables using unpacking.</p>"},{"location":"data_structures/sequence/#parallel-assignment","title":"Parallel assignment","text":"<p>The most visible form of unpacking, assigning items from an iterable to tuple of variable.</p> unpacking_parallel_assignment.py<pre><code>&gt;&gt;&gt; point = (123, 456)\n&gt;&gt;&gt; x, y = point\n&gt;&gt;&gt; print(f\"X: {x}\")\n&gt;&gt;&gt; print(f\"Y: {y}\")\nX: 123\nY: 456\n</code></pre> swapping_var_values.py<pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 15\n&gt;&gt;&gt; b, a = a, b\n&gt;&gt;&gt; print(f\"A: {a}, B: {b}\")\nA: 15, B: 10\n</code></pre>"},{"location":"data_structures/sequence/#using","title":"Using *","text":"<p>Use the <code>*</code> prefix when calling a function to perform <code>unpacking of elements from a sequence</code>. It allows you to pass <code>multiple arguments from a sequence as individual arguments</code> to the function.</p> unpacking_multiple_sequence.py<pre><code>&gt;&gt;&gt; data = (20, 8)\n&gt;&gt;&gt; quotient, remainder = divmod(*data)\n&gt;&gt;&gt; print(quotient, remainder)\n2 4\n</code></pre> <p>Using <code>*</code> to grab excess items</p> excess_items_unpacking.py<pre><code>&gt;&gt;&gt; a, b, *rest = range(5)\n&gt;&gt;&gt; print(\"REST ITEMS\")\n&gt;&gt;&gt; print(f\"WITH 5 =&gt; A: {a}, B: {b}, REST: {rest}\")\n&gt;&gt;&gt; a, b, *rest = range(3)\n&gt;&gt;&gt; print(f\"WITH 3 =&gt; A: {a}, B: {b}, REST: {rest}\")\n&gt;&gt;&gt; a, b, *rest = range(2)\n&gt;&gt;&gt; print(f\"WITH 2 =&gt; A: {a}, B: {b}, REST: {rest}\")\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; a, *body, c, d = range(5)\n&gt;&gt;&gt; print(\"MIDDLE ITEMS\")\n&gt;&gt;&gt; print(f\"A: {a}, BODY: {body}, C: {c}, D: {d}\")\n&gt;&gt;&gt; *head, b, c, d = range(5)\n&gt;&gt;&gt; print(f\"HEAD: {head}, B: {b}, C: {c}, D: {d}\")\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; print(\"In Function Calls\")\n&gt;&gt;&gt; def fun(a, b, c, d, *rest):\n...     return a, b, c, d, rest\n&gt;&gt;&gt; print(fun(*[1, 2], 3, *range(4, 7)))\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; print(\"When defining list, tuple or set\")\n&gt;&gt;&gt; print(*range(4), 4)\n&gt;&gt;&gt; print([*range(4), 4])\n&gt;&gt;&gt; print({*range(4), 4, *(5, 6, 7)})\nREST ITEMS\nWITH 5 =&gt; A: 0, B: 1, REST: [2, 3, 4]\nWITH 3 =&gt; A: 0, B: 1, REST: [2]\nWITH 2 =&gt; A: 0, B: 1, REST: []\nMIDDLE ITEMS\nA: 0, BODY: [1, 2], C: 3, D: 4\nHEAD: [0, 1], B: 2, C: 3, D: 4\nIn Function Calls\n(1, 2, 3, 4, (5, 6))\nWhen defining list, tuple or set\n0 1 2 3 4\n[0, 1, 2, 3, 4]\n{0, 1, 2, 3, 4, 5, 6, 7}\n</code></pre>"},{"location":"data_structures/sequence/#with-functions-return","title":"With function's return","text":"<p>You can use unpacking from function returns to allow functions to <code>return multiple values</code> conveniently. The caller can easily unpack the values into separate variables.</p> swapping_var_values.py<pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; # doesn't work with strings\n&gt;&gt;&gt; raw_return = os.path.split('/home/aws_nice_cluster/.ssh/id_rsa.pub') \n&gt;&gt;&gt; print(f\"raw_return: {raw_return}, type: {type(raw_return)}\")\n&gt;&gt;&gt; _, filename = raw_return\n&gt;&gt;&gt; print(filename)\nraw_return: ('/home/aws_nice_cluster/.ssh', 'id_rsa.pub'), type: &lt;class 'tuple'&gt;\nid_rsa.pub\n</code></pre>"},{"location":"data_structures/sequence/#nested-unpacking","title":"Nested Unpacking","text":"swapping_var_values.py<pre><code>&gt;&gt;&gt; metro_areas = [\n...    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),  \n...    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),\n...    ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n&gt;&gt;&gt; print(f'{\"\":15} | {\"latitude\":&gt;9} | {\"longitude\":&gt;9}')\n&gt;&gt;&gt; for name, _, _, (lat, lon) in metro_areas:  \n...     if lon &lt;= 0:  \n...         print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n                |  latitude | longitude\nMexico City     |   19.4333 |  -99.1333\nNew York-Newark |   40.8086 |  -74.0204\nS\u00e3o Paulo       |  -23.5478 |  -46.6358\n</code></pre>"},{"location":"data_structures/sequence/#pattern-matching","title":"Pattern Matching","text":"<p>Available in Python 3.10 and above!</p> <p>In Python's pattern matching, the <code>subject</code> is the data following the <code>match</code> keyword, which Python aims to <code>match with patterns in each case clause</code>.  One key improvement of match over switch is <code>destructuring</code> - a more advanced form of unpacking the subject. A case clause has two parts: a <code>pattern</code> and an <code>optional guard with the if keyword</code>.</p> <p>For subject <code>sequence pattern</code> matching, the following is necessary:</p> <ol> <li>The subject  is a sequence;</li> <li>The subject and the pattern have the same number of items and;</li> <li>Each corresponding item matches, including nested items.</li> </ol> sequence_matching_basic.py<pre><code>&gt;&gt;&gt; def demonstration(self, message_type: list[str]) -&gt; str:\n...     match message_type: # message_type is the SUBJECT\n...         case ['AAAA', 'BBB', 'CCC']:\n...             return 'ABC'\n...         case ['BBB', 'CCC']:\n...             return 'BC'\n...         case ['CCC']:\n...             return 'C'\n...         case _:\n...             return ''\n</code></pre> sequence_matching_complex.py<pre><code>&gt;&gt;&gt; metro_areas = [\n...     ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),\n...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...     ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),\n...     ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n&gt;&gt;&gt; print(f'{\"\":15} | {\"latitude\":&gt;9} | {\"longitude\":&gt;9}')\n&gt;&gt;&gt; for record in metro_areas:\n&gt;&gt;&gt;     match record:  \n&gt;&gt;&gt;         case [name, _, _, (lat, lon)] if lon &lt;= 0: # using IF on case clause\n&gt;&gt;&gt;             print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n                |  latitude | longitude\nMexico City     |   19.4333 |  -99.1333\nNew York-Newark |   40.8086 |  -74.0204\nS\u00e3o Paulo       |  -23.5478 |  -46.6358\n</code></pre>"},{"location":"data_structures/sequence/#special-treatment","title":"Special Treatment","text":"<ol> <li>In sequence patterns, <code>both square brackets and parentheses have the same significance</code>;</li> <li> <p>Cannot match sequences of type <code>str</code>, <code>bytes</code> and <code>bytearray</code>:</p> <ol> <li>A match subject of those types is <code>treated as an atomic value</code>;</li> <li>To treat as a sequence, <code>convert it in the match clause</code>;</li> </ol> <p>convert_str_match.py<pre><code>&gt;&gt;&gt; def phone_location(phone: str):\n&gt;&gt;&gt;     match tuple(phone):\n...         case ['1', *rest]:  # North America and Caribbean\n...             return 1\n...         case ['2', *rest]:  # Africa and some territories\n...             return 2\n...         case ['3' | '4', *rest]:  # Europe\n...             return 3\n</code></pre> </p> </li> <li> <p>The <code>_</code> symbol: it matches any single item in that position, but it is never bound to the value to the match item:</p> <ol> <li>Also, the only variable that <code>can appear more than once</code></li> </ol> using_.py<pre><code># ['Shanghai', 'CN', 24.9, (31.1, 121.3)]\ncase [name, _, _, (lat, lon) as coord]: \n# name = Shanghai\n# lat = 31.1\n# lon = 121.3\n# coord = (31.1, 121.3)\n</code></pre> </li> </ol>"},{"location":"data_structures/sequence/#examples","title":"Examples","text":"<p>First case:</p> <ol> <li>The first item must be an instance of <code>str</code>;</li> <li>Item 3 must be a <code>pair of floats</code>.</li> </ol> match_by_type.py<pre><code>case [str(name), _, _, (float(lat), float(lon))]:\n</code></pre> <p>Second case:</p> <ol> <li>Match any subject sequence <code>starting with a str</code></li> <li>Ending with a <code>nested sequence of two floats</code></li> </ol> match_by_type.py<pre><code>case [str(name), *_, (float(lat), float(lon))]:\n</code></pre> <ul> <li>The <code>*_</code> matches any number of items, <code>without binding them to a variable</code>;</li> <li>Using <code>*extra</code> instead of *_ would bind the items to <code>extra as a list</code> with 0 or more items.</li> </ul>"},{"location":"data_structures/sequence/#generator-expressions","title":"Generator Expressions","text":"<p>Generator expressions (gen-expr) are employed to <code>construct sequences</code>.  They <code>save memory by yielding items one by one</code> via the iterator protocol, unlike listcomps, which builds an entire list before feeding another constructor. Generator expressions share the same syntax as listcomps but <code>use parentheses</code> instead of brackets.</p> <p>Variables assigned using the \"Walrus operator\" <code>:= remain accessible after the comprehensions or expressions from which they originate return</code>, unlike local variables within functions. The scope of the target of := is the enclosing function, unless a global or nonlocal declaration is made for that target.</p> gen_enx.py<pre><code>&gt;&gt;&gt; symbols = '$\u00a2\u00a3\u00a5\u20ac\u00a4'\n&gt;&gt;&gt; order_symbols = tuple(ord(symbol) for symbol in symbols)\n&gt;&gt;&gt; print(order_symbols)\n&gt;&gt;&gt; string_int = \"12345\"\n&gt;&gt;&gt; raw_gen = (value for value in string_int) \n&gt;&gt;&gt; print(type(raw_gen))\n&gt;&gt;&gt; print(set(raw_gen))\n&gt;&gt;&gt; codes = [last := ord(c) for c in string_int]\n&gt;&gt;&gt; print(last)\n(36, 162, 163, 165, 8364, 164)\n&lt;class 'generator'&gt;\n{'1', '2', '3', '4', '5'}\n53\n</code></pre>"},{"location":"data_structures/sequence/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"data_structures/set/","title":"Set","text":"<p>A set is a built-in data structure in Python and is classified as a type of sequence data structure.</p>"},{"location":"data_structures/set/#characteristics","title":"Characteristics","text":"<ol> <li>Mutable Sequence</li> <li>Container Sequence</li> <li>Eliminate all duplicates</li> <li>Unordered</li> <li>Support mathematical operations like union, intersection, difference, and symmetric difference</li> <li>Usually homogeneous</li> </ol>"},{"location":"data_structures/set/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Python - Sets</li> </ul>"},{"location":"data_structures/tuple/","title":"Tuple","text":"<p>A set is a built-in data structure in Python and is classified as a type of sequence data structure.</p>"},{"location":"data_structures/tuple/#characteristics","title":"Characteristics","text":"<ol> <li>Immutable Sequence</li> <li>Container Sequence</li> <li>Can be used as record</li> <li>Just the tuple object is immutable, the tuple's element can change.</li> <li>Use parentheses ()</li> <li>Usually contain a heterogeneous sequence</li> </ol>"},{"location":"data_structures/tuple/#the-tuples-references-to-mutable-objects","title":"The Tuples references to Mutable Objects","text":"<p>Basic concepts:</p> <ol> <li>Object References</li> </ol> <p>The concept of <code>immutability in tuples specifically pertains to the tuple's references</code>. It's crucial to note that while tuples themselves are immutable, this <code>immutability does not extend to the mutable objects they may reference</code>. Care should be taken when dealing with tuples containing mutable items to avoid potential sources of bugs.</p> tuple_refs.py<pre><code>&gt;&gt;&gt; a = (10, 'alpha', [1, 2])\n&gt;&gt;&gt; b = (10, 'alpha', [1, 2])\n&gt;&gt;&gt; print(f\"a == b? {a == b}, A type = {type(a)} and B type = {type(b)}\")\n&gt;&gt;&gt; b[-1].append(99)\n&gt;&gt;&gt; print(f\"a == b? {a == b}\")\n&gt;&gt;&gt; print(f\"A now: {a} vs B now: {b}\")\na == b? True, A type = &lt;class 'tuple'&gt; and B type = &lt;class 'tuple'&gt;\na == b? False\nA now: (10, 'alpha', [1, 2]) vs B now: (10, 'alpha', [1, 2, 99])\n</code></pre>"},{"location":"data_structures/tuple/#tuples-as-records","title":"Tuples as Records","text":"<p>If you are <code>familiar with the structure</code> of tuple objects, you can utilize tuples as record data, with each <code>item in the tuple representing data for a specific field</code>. The sequence of items holds significance, and the count of fields remains constant.</p> tuple_as_records.py<pre><code>&gt;&gt;&gt; countries_nationality = [('Chile', 'Chilean'), ('Brazil', 'Brazilian'), ('Argentina', 'Argentine'), ('Uruguay', 'Uruguayan')]\n&gt;&gt;&gt; for country, nationality in countries_nationality:\n...     print(f\"Country field: {country}, Nationality: {nationality}\")\nCountry field: Chile, Nationality: Chilean\nCountry field: Brazil, Nationality: Brazilian\nCountry field: Argentina, Nationality: Argentine\nCountry field: Uruguay, Nationality: Uruguayan\n</code></pre>"},{"location":"data_structures/tuple/#tuples-vs-lists","title":"Tuples vs Lists","text":"<p>Using Tuples instead of Lists can bring both <code>performance benefits and clarity</code> to your code:</p> <ol> <li>Clarity: When you encounter a tuple in the code, you can be certain that its <code>length will remain constant</code>.</li> <li>Performance: <code>Tuples consume less memory</code> compared to a list of equivalent length, enabling Python to implement optimizations.</li> </ol> <p>A deeper discussion can be found here in this StackOverflow answer by Python core developer Raymond Hettinger</p> <p>A deeper discussion can be found here in this StackOverflow answer provided by Raymond Hettinger, a Python core developer.</p>"},{"location":"data_structures/tuple/#named-tuples","title":"Named Tuples","text":"<p>Named tuples in Python offer a way to <code>create tuples that enable you to access values using descriptive field names and the dot notation</code>, instead of relying on ambiguous integer indices.</p>"},{"location":"data_structures/tuple/#collectionsnamedtuple","title":"collections.namedtuple","text":"<p>Python's <code>namedtuple()</code> resides within the <code>collections</code> module as a factory function. It empowers you to generate <code>subclasses of tuples</code>, complete with named fields. This offers supplementary methods and attributes like <code>._make()</code>, <code>_asdict()</code>, and .<code>_fields</code>, among others. Notably, named tuples <code>maintain backward compatibility</code> with conventional tuples while <code>exhibiting comparable memory usage</code>.</p> named_tuple_collections.py<pre><code>&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Point = namedtuple(\"Point\", \"x y\")\n&gt;&gt;&gt; print(f\"Is subclass of tuple? {issubclass(Point, tuple)}\")\n&gt;&gt;&gt; point = Point(2, 4)\n&gt;&gt;&gt; print(point, point.x, point.y)\n&gt;&gt;&gt; print(point, point[0], point[1])\nIs subclass of tuple? True\nPoint(x=2, y=4) 2 4\nPoint(x=2, y=4) 2 4\n</code></pre> <p>For further customization, including required and optional arguments, along with other details, see the the Real Python article.</p>"},{"location":"data_structures/tuple/#typingnamedtuple","title":"typing.NamedTuple","text":"<p>Within the <code>typing</code> module, there exists <code>NamedTuple</code>, a typed variant of namedtuple. This allows to craft namedtuple classes with <code>type annotations</code>. Notably, <code>both namedtuple and NamedTuple instances exhibit identical memory consumption characteristics</code>.</p> named_tuple_typing.py<pre><code>&gt;&gt;&gt; from typing import NamedTuple\n&gt;&gt;&gt; class Person(NamedTuple):\n...     name: str\n...     age: int\n...     country: str = \"Canada\"\n</code></pre>"},{"location":"data_structures/tuple/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Python - Tuples and Sequences</li> <li>Real Python - Write Pythonic and Clean Code With namedtuple</li> </ul>"},{"location":"functions/basic/","title":"Basic of Functions","text":""},{"location":"functions/basic/#definitions-and-arguments","title":"Definitions and Arguments","text":"<p>The <code>def</code> keyword introduces a function definition, followed by the function name and a list of formal parameters enclosed in parentheses. The function body starts on the next line and must be indented.</p> <p>When a function is called, the actual parameters (arguments) are introduced into the local symbol table of the called function. This is done using \"call by value,\" where the value passed is always an object reference, not the value of the object itself. If a function calls another function or itself recursively, a new local symbol table is created for that call.</p> fun_definition.py<pre><code>&gt;&gt;&gt; def add_number(num1: int, num2: int) -&gt; int:\n...     # typing arguments and return are optional\n...     return num1 + num2\n</code></pre> <p>Functions that belong to a class require the first argument to be <code>self</code>, which is used to pass the object reference to the function. This enables access to the class's attributes and methods within the function's body.</p> fun_class.py<pre><code>&gt;&gt;&gt; class Nice:\n...     ...\n&gt;&gt;&gt;     def nice_func(self):\n...         print(\"Nice object func starting with self\")\n</code></pre>"},{"location":"functions/basic/#return","title":"Return","text":"<p>Functions in Python can indeed return multiple values. When a function is called, it can produce multiple results. This capability allows functions to provide comprehensive information or results that can be used further in the code.</p> mult_return.py<pre><code>&gt;&gt;&gt; def add_sub_numbers(num1: int, num2: int) -&gt; tuple[int, int]:\n...     return num1 + num2, num1 - num2\n&gt;&gt;&gt; print(add_sub_numbers(2, 2))\n(4, 0)\n</code></pre> <p>Moreover, even functions that do not explicitly contain a return statement still return a value, albeit a default and unexciting one called <code>None</code>. When the return statement is missing, the interpreter automatically returns <code>None</code> as the function's output.</p> fun_none.py<pre><code>&gt;&gt;&gt; def add_number_print(num1: int, num2: int):\n...     print(num1 + num2)\n&gt;&gt;&gt; print(add_number_print(2, 2))\n4\nNone\n</code></pre>"},{"location":"functions/basic/#the-nine-types-of-callable-objects","title":"The Nine Types of Callable Objects","text":"<p>To determine whether an object is callable, use the\u00a0<code>callable()</code>\u00a0built-in function.</p>"},{"location":"functions/basic/#user-defined-functions","title":"User-Defined Functions","text":"<p>Created with <code>def</code> statements or <code>lambda</code> expressions;</p>"},{"location":"functions/basic/#built-in-functions","title":"Built-in Functions","text":"<p>A\u00a0function implemented in C (for CPython), like\u00a0<code>len</code>\u00a0or\u00a0<code>time.strftime</code>.</p>"},{"location":"functions/basic/#built-in-methods","title":"Built-in Methods","text":"<p>Methods\u00a0implemented in C, like\u00a0<code>dict.get</code>.</p>"},{"location":"functions/basic/#methods","title":"Methods","text":"<p>Functions defined in the body of a class.</p>"},{"location":"functions/basic/#classes","title":"Classes","text":"<p>When\u00a0invoked, a class runs its\u00a0<code>__new__</code>\u00a0method to create an instance, then\u00a0<code>__init__</code>\u00a0to initialize it, and finally the instance is returned to the caller;</p>"},{"location":"functions/basic/#class-instances","title":"Class instances","text":"<p>If a class defines a\u00a0<code>__call__</code>\u00a0method, then its instances may be invoked as functions;</p>"},{"location":"functions/basic/#generator-functions","title":"Generator Functions","text":"<p>Functions or methods that use the\u00a0<code>yield</code>\u00a0keyword in their body. When called, they return a generator object.</p>"},{"location":"functions/basic/#native-coroutine-functions","title":"Native Coroutine Functions","text":"<p>Functions\u00a0or methods defined with\u00a0<code>async def</code>. When called, they return a coroutine object.</p>"},{"location":"functions/basic/#asynchronous-generator-functions","title":"Asynchronous Generator Functions","text":"<p>Functions\u00a0or methods defined with\u00a0<code>async def</code>\u00a0that have\u00a0<code>yield</code>\u00a0in their body. When called, they return an asynchronous generator for use with\u00a0<code>async for</code></p>"},{"location":"functions/basic/#references","title":"References","text":"<ul> <li>Python - 4.7. Defining Functions</li> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"functions/hof_lamda_functions/","title":"High-Order and Lambda Function","text":""},{"location":"functions/hof_lamda_functions/#high-order-functions","title":"High-Order Functions","text":"<p>A function is classified as a Higher Order Function (HOF) when it <code>takes other functions as parameters or returns a function as its output</code>. In other words, HOFs are functions that interact with other functions. Common examples of HOFs include map, filter, and reduce. These functions accept any one-argument function as a key.</p> <p>Key properties of higher-order functions:</p> <ol> <li>Functions are instances of the Object type.</li> <li>Functions can be stored in variables.</li> <li>Functions can be passed as parameters to other functions.</li> <li>Functions can be returned from a function.</li> <li>Functions can be stored in data structures like hash tables and lists.</li> </ol> lambda.py<pre><code>&gt;&gt;&gt; fruits = ['banana', 'apple', 'fig', 'strawberry', 'cherry', 'raspberry']\n&gt;&gt;&gt; def reverse(word):\n...     return word[::-1]\n&gt;&gt;&gt; print(reverse('testing'))\n&gt;&gt;&gt; print(list(map(reverse, fruits)))\ngnitset\n['ananab', 'elppa', 'gif', 'yrrebwarts', 'yrrehc', 'yrrebpsar']\n</code></pre>"},{"location":"functions/hof_lamda_functions/#anonymouslambda-functions","title":"Anonymous/Lambda Functions","text":"<p>Lambda functions can be used wherever function objects are required. They can only contain <code>pure expressions and cannot include other Python statements</code> like while, try, or assignment statements. Despite these limitations, lambda functions are semantically <code>equivalent to normal function definitions and act as syntactic sugar for them.</code> Lambda functions are commonly used when a simple, short function is required, and there's no need to define a full-fledged function using the def statement. Like nested function definitions, lambda functions can reference variables from the containing scope:</p> lambda.py<pre><code>&gt;&gt;&gt; def make_incrementor(n):\n...    return lambda x: x + n\n&gt;&gt;&gt; f = make_incrementor(42)\n&gt;&gt;&gt; print(f(0))\n&gt;&gt;&gt; print(f(1))\n42\n43\n</code></pre> lambda2.py<pre><code>&gt;&gt;&gt; fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']\n&gt;&gt;&gt; print(sorted(fruits, key=lambda word: word[::-1]))\n['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry']\n</code></pre>"},{"location":"functions/hof_lamda_functions/#references","title":"References","text":"<ul> <li>Geeks for Geeks - Higher Order Functions in Python</li> </ul>"},{"location":"functions/packages_funtional_programming/","title":"Packages for Funtional Programming","text":""},{"location":"functions/packages_funtional_programming/#operator-and-functools-modules","title":"Operator and Functools Modules","text":"<p>The <code>operator</code> module provides functions equivalents for dozens of operators so you don\u2019t have to code trivial function like <code>lambda a, b: a*b.</code></p> <p>The\u00a0<code>functools</code>\u00a0module provides several higher-order functions.</p> lambda.py<pre><code>&gt;&gt;&gt; def factorial(n):\n...    return reduce(lambda a, b: a*b, range(1, n+1))\n&gt;&gt;&gt; \n&gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; from operator import mul\n&gt;&gt;&gt; def factorial(n):\n...    return reduce(mul, range(1, n+1))\n</code></pre> <p>List of public functions defined in <code>operator</code> and <code>functools</code>:</p> lambda.py<pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; print([name for name in dir(operator) if not name.startswith('_')])\n&gt;&gt;&gt; import functools\n&gt;&gt;&gt; print([name for name in dir(functools) if not name.startswith('_')])\n['abs', 'add', 'and_', 'attrgetter', 'call', 'concat', 'contains', 'countOf', 'delitem', 'eq', 'floordiv', 'ge', 'getitem', 'gt', 'iadd', 'iand', 'iconcat', 'ifloordiv', 'ilshift', 'imatmul', 'imod', 'imul', 'index', 'indexOf', 'inv', 'invert', 'ior', 'ipow', 'irshift', 'is_', 'is_not', 'isub', 'itemgetter', 'itruediv', 'ixor', 'le', 'length_hint', 'lshift', 'lt', 'matmul', 'methodcaller', 'mod', 'mul', 'ne', 'neg', 'not_', 'or_', 'pos', 'pow', 'rshift', 'setitem', 'sub', 'truediv', 'truth', 'xor']\n['GenericAlias', 'RLock', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES', 'cache', 'cached_property', 'cmp_to_key', 'get_cache_token', 'lru_cache', 'namedtuple', 'partial', 'partialmethod', 'recursive_repr', 'reduce', 'singledispatch', 'singledispatchmethod', 'total_ordering', 'update_wrapper', 'wraps']\n</code></pre>"},{"location":"functions/packages_funtional_programming/#examples","title":"Examples","text":""},{"location":"functions/packages_funtional_programming/#itemgetter-and-attrgetter","title":"Itemgetter and Attrgetter","text":"<p><code>itemgetter</code> and <code>attrgetter</code> are factories that pick items from sequences or read attributes from object.</p> <p><code>itemgetter</code> uses the <code>[]</code> operator, it supports not only sequences but also mappings and any class that implements <code>__getitem__</code>;</p> lambda.py<pre><code>&gt;&gt;&gt; metro_data = [\n...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...     ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n&gt;&gt;&gt; from operator import itemgetter\n&gt;&gt;&gt; for city in sorted(metro_data, key=itemgetter(1)):\n...     print(city)\n&gt;&gt;&gt; cc_name = itemgetter(1, 0)\n&gt;&gt;&gt; for city in metro_data:\n...     print(cc_name(city))\n('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833))\n('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889))\n('Mexico City', 'MX', 20.142, (19.433333, -99.133333))\n('IN', 'Delhi NCR')\n('MX', 'Mexico City')\n('BR', 'S\u00e3o Paulo')\n</code></pre> <p><code>attrgetter</code> creates functions to <code>extract object attributes by name</code>. <code>attrgetter</code> can navigate through nested objects that contains a .(dot), to retrieve the attribute.</p> lambda.py<pre><code>&gt;&gt;&gt; metro_data = [\n...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...     ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n&gt;&gt;&gt; \n&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; LatLon = namedtuple('LatLon', 'lat lon')  \n&gt;&gt;&gt; Metropolis = namedtuple('Metropolis', 'name cc pop coord')  \n&gt;&gt;&gt; metro_areas = [Metropolis(name, cc, pop, LatLon(lat, lon))  \n...     for name, cc, pop, (lat, lon) in metro_data]\n&gt;&gt;&gt; print(metro_areas[0])\n&gt;&gt;&gt; from operator import attrgetter\n&gt;&gt;&gt; name_lat = attrgetter('name', 'coord.lat') \n&gt;&gt;&gt; for city in sorted(metro_areas, key=attrgetter('coord.lat')):  \n...     print(name_lat(city))\nMetropolis(name='Delhi NCR', cc='IN', pop=21.935, coord=LatLon(lat=28.613889, lon=77.208889))\n('S\u00e3o Paulo', -23.547778)\n('Mexico City', 19.433333)\n('Delhi NCR', 28.613889)\n</code></pre>"},{"location":"functions/packages_funtional_programming/#methodcaller","title":"Methodcaller","text":"<p>Creates a function that calls a method by name on the object  given as argument.</p> lambda.py<pre><code>&gt;&gt;&gt; from operator import methodcaller\n&gt;&gt;&gt; s = 'The time has come'\n&gt;&gt;&gt; upcase = methodcaller('upper')\n&gt;&gt;&gt; print(upcase(s))\n&gt;&gt;&gt; hyphenate = methodcaller('replace', ' ', '-')\n&gt;&gt;&gt; print(hyphenate(s))\nTHE TIME HAS COME\nThe-time-has-come\n</code></pre>"},{"location":"functions/packages_funtional_programming/#partial-freezing-arguments","title":"Partial freezing arguments","text":"<p>Given a callable, it produces a new callable with some of the arguments of the original <code>callable bound to predetermined values</code>. <code>partial</code>\u00a0takes a callable as first argument, followed by an arbitrary number of positional and keyword arguments to bind. The\u00a0<code>functools.partialmethod</code>\u00a0function does the same job as\u00a0partial, but is designed to work with <code>methods</code>.</p> lambda.py<pre><code>&gt;&gt;&gt; from operator import mul\n&gt;&gt;&gt; from functools import partial\n&gt;&gt;&gt; triple = partial(mul, 3)\n&gt;&gt;&gt; print(triple(7))\n&gt;&gt;&gt; result = list(map(triple, range(1, 10)))\n&gt;&gt;&gt; print(result)\n21\n[3, 6, 9, 12, 15, 18, 21, 24, 27]\n</code></pre>"},{"location":"functions/packages_funtional_programming/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"functions/parameters/","title":"Parameters","text":"<p>In Python, parameter passing follows the concept of <code>call by sharing</code>. This means that each formal parameter of the function receives a copy of each reference in the arguments. As a result, the parameters inside the function become aliases of the actual arguments. While the <code>function can modify any mutable object passed as a parameter</code>, it cannot change the identity of those objects.</p> <p>Understanding this mechanism is crucial for working with functions in Python, as it ensures that modifications to parameters within a function do not affect the original objects in the calling code.</p> parameters.py<pre><code>&gt;&gt;&gt; def nice_function(a, b):\n...     a += b\n...     return a\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 2\n&gt;&gt;&gt; print(f\"nice_function(x, y): {nice_function(x, y)}\")\n&gt;&gt;&gt; print(f\"X and Y didn't change: {x , y}\")\n&gt;&gt;&gt; print(\"Reason: int is immutable\")\n&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; print(f\"nice_function(a, b): {nice_function(a, b)}\")\n&gt;&gt;&gt; print(f\"A and B change: {a , b}\")\n&gt;&gt;&gt; print(\"Reason: list is mutable\")\nnice_function(x, y): 3\nX and Y didn't change: (1, 2)\nReason: int is immutable\nnice_function(a, b): [1, 2, 3, 4]\nA and B change: ([1, 2, 3, 4], [3, 4])\nReason: list is mutable\n</code></pre>"},{"location":"functions/parameters/#default-arguments","title":"Default Arguments","text":"default_arguments.py<pre><code>&gt;&gt;&gt; def nice_some(a = 2, b =2):\n...     # int is immutable, SO ALL GOOD!\n...     return a + b\n&gt;&gt;&gt; print(nice_some())\n&gt;&gt;&gt; print(nice_some(50))\n&gt;&gt;&gt; print(nice_some(50, 50))\n4\n52\n100\n</code></pre>"},{"location":"functions/parameters/#mutable-types-as-deafults-bad-idea","title":"Mutable Types as Deafults: Bad Idea","text":"<p>Default values in Python functions are evaluated at the time of function definition, in the defining scope. As a result, the <code>default value is evaluated only once</code>, and this becomes significant when the default value is a mutable object, like a list, dictionary, or instances of most classes.</p> <p>If a default value is a mutable object, and you <code>modify it within the function, the change will affect all future calls to the function</code>. This is because instances that don't receive an initial value for a mutable default parameter end up sharing the same variable reference.</p> <p>To avoid unexpected behavior, it's common to use None as the default value for parameters that may receive mutable values. By doing so, you ensure that each call to the function receives its independent mutable object, preventing any unintended side effects across different function calls.</p> default_mutable_arguments.py<pre><code>&gt;&gt;&gt; def f(a, L=[]):\n...    L.append(a)\n...    return L\n&gt;&gt;&gt; print(f(1))\n&gt;&gt;&gt; print(f(2))\n&gt;&gt;&gt; print(f(3))\n[1]\n[1, 2]\n[1, 2, 3]\n</code></pre> src/functions/deep_mutable_arg.py<pre><code>## Take from Fluent Python, 2nd Edition (https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/)\nclass TwilightBusWrong:\ndef __init__(self, passengers=None):\nif passengers is None:\nself.passengers = []  \nelse:\n# create a aliases for list passed\nself.passengers = passengers  \ndef pick(self, name):\nself.passengers.append(name)\ndef drop(self, name):\nself.passengers.remove(name)\nclass TwilightBusRight:\ndef __init__(self, passengers=None):\nif passengers is None:\nself.passengers = []\nelse:\n# create a new LIST, making a copy from list passed\nself.passengers = list(passengers) \ndef pick(self, name):\nself.passengers.append(name)\ndef drop(self, name):\nself.passengers.remove(name)\n</code></pre>"},{"location":"functions/parameters/#positional-or-keyword-parameters","title":"Positional or Keyword Parameters","text":"<p>If the parameter type (positional or keyword) is not explicitly specified, it is possible to pass the argument in both ways.</p> positional_keyword.py<pre><code>&gt;&gt;&gt; def example_function(a, b, c):\n...    print(a, b, c)\n&gt;&gt;&gt; # Both ways of calling the function are valid:\n&gt;&gt;&gt; example_function(1, 2, 3)       # Positional arguments\n&gt;&gt;&gt; example_function(c=3, b=2, a=1) # Keyword arguments\n1 2 3\n1 2 3\n</code></pre>"},{"location":"functions/parameters/#positional-only-parameters","title":"Positional-Only Parameters","text":"<p>Positional-only parameters in Python functions are ordered in a way that their <code>sequence matters</code>, and they cannot be passed using keywords. These parameters are designated by being <code>placed before a forward-slash (/) in the function definition</code>. The forward-slash serves as a logical separator, indicating the boundary between the positional-only parameters and the rest of the parameters.</p> positional_only.py<pre><code>&gt;&gt;&gt; def example_function(a, b, /, c, d):\n...     print(a, b, c, d)\n... # Calling the function using positional arguments only:\n&gt;&gt;&gt; example_function(1, 2, 3, 4)\n... # Using positional and keyword arguments together:\n&gt;&gt;&gt; example_function(3, 1, c=2, d=7)\n... # example_function(3, b=1, c=2, d=7) b=1 generates an error because B cannot be keyword\n1 2 3 4\n3 1 2 7\n</code></pre>"},{"location":"functions/parameters/#keyword-only-parameters","title":"Keyword-Only Parameters","text":"<p>To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, place an <code>* in the arguments list just before the first keyword-only parameter</code>.</p> keyword_only.py<pre><code>&gt;&gt;&gt; def example_function(a, b, *, c, d):\n...     print(a, b, c, d)\n... # Calling the function using positional arguments only:\n&gt;&gt;&gt; example_function(1, 2, c=3, d=4)\n... # Using positional and keyword arguments together:\n&gt;&gt;&gt; example_function(3, b=1, c=2, d=7) # No problem, just C and D NEEDS to be keyword\n... # example_function(3, 1, 2, d=7) ERROR C is not Keyword\n1 2 3 4\n3 1 2 7\n</code></pre>"},{"location":"functions/parameters/#positional-and-keyword-parameters","title":"Positional and Keyword Parameters","text":"<p>If <code>/</code> and <code>*</code> are not present in the function definition, arguments may be passed to a function by position or by keyword.</p> <pre><code>def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n      -----------    ----------     ----------\n        |             |                  |\n        |        Positional or keyword   |\n        |                                - Keyword only\n         -- Positional only\n</code></pre>"},{"location":"functions/parameters/#arbitrary-argument-lists","title":"Arbitrary Argument Lists","text":"<p>Python functions can be defined to <code>accept an arbitrary number of arguments by using the asterisk (*) symbol before the parameter name</code>. This allows the function to be called with any number of arguments, and these arguments will be <code>bundled together into a tuple.</code></p> arbitrary_args.py<pre><code>&gt;&gt;&gt; def write_multiple_items(file, separator, *args):\n...    file.write(separator.join(args))\n</code></pre> <p>Normally, these arbitrary argumen are typically placed last in the list of formal parameters of a function. This allows them to collect any additional input arguments that are passed to the function. <code>After the *args parameter, any subsequent formal parameters are considered 'keyword-only' arguments</code>, which means they can only be used as keywords when calling the function, rather than being passed as positional arguments.</p> arbitrary_args2.py<pre><code>&gt;&gt;&gt; def example_function(a, b, *args, c, d):\n...    print(f\"a: {a}, b: {b}\")\n...    print(f\"Additional arguments {args}, type {type(args)}\")\n...    print(f\"c: {c}, d: {d}\")\n&gt;&gt;&gt; example_function(1, 2, 3, 4, 5, c=6, d=7)\n&gt;&gt;&gt; example_function(10, 20, c=30, d=40)\na: 1, b: 2\nAdditional arguments (3, 4, 5), type &lt;class 'tuple'&gt;\nc: 6, d: 7\na: 10, b: 20\nAdditional arguments (), type &lt;class 'tuple'&gt;\nc: 30, d: 40\n</code></pre>"},{"location":"functions/parameters/#unpacking-argument-lists","title":"Unpacking Argument Lists","text":"unpacking_args.py<pre><code>&gt;&gt;&gt; def parrot(voltage, state='a stiff', action='voom'):\n...    print(\"-- This parrot wouldn't\", action, end=' ')\n...    print(\"if you put\", voltage, \"volts through it.\", end=' ')\n...    print(\"E's\", state, \"!\")\n&gt;&gt;&gt; d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n&gt;&gt;&gt; parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n</code></pre>"},{"location":"functions/parameters/#references","title":"References","text":"<ul> <li> <p>Python - 4.8. More on Defining Functions</p> </li> <li> <p>Fluent Python, 2nd Edition</p> </li> </ul>"},{"location":"functions/type_hits/","title":"Type Hits in Functions","text":""},{"location":"functions/user_defined_callable_types/","title":"User-Defined Callable Types","text":"<p>In Python, we can make arbitrary objects behave like functions by implementing a <code>__call__</code> instance method. This simple approach allows us to create function-like objects with internal state that persists across invocations. By defining the <code>__call__</code> method, we enable instances of the class to be callable, just like regular functions.</p> user_callable_object.py<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; class BingoCage:\n&gt;&gt;&gt;     def __init__(self, items):\n...        self._items = list(items)  \n...        random.shuffle(self._items)  \n&gt;&gt;&gt;     def pick(self):\n...        try:\n...            return self._items.pop()\n...        except IndexError:\n...            raise LookupError('pick from empty BingoCage')  \n&gt;&gt;&gt;     def __call__(self):\n...        return self.pick()\n&gt;&gt;&gt; bingo = BingoCage(range(3))\n&gt;&gt;&gt; print(bingo.pick())\n&gt;&gt;&gt; print(bingo())\n&gt;&gt;&gt; print(callable(bingo))\n0\n2\nTrue\n</code></pre>"},{"location":"functions/user_defined_callable_types/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"}]}