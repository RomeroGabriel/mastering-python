{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Python","text":"<p>A particular but not private repository to centralize all studies about Python and a few famous Python's libraries. It's kind my own documentation about the language. </p>"},{"location":"#python-versions-supported","title":"Python Versions Supported","text":"<ul> <li>Python 3.11 or lower</li> </ul>"},{"location":"#backlog","title":"Backlog","text":"<ul> <li>Python 3.12 news</li> </ul>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>W3Schools - Python</li> <li>Fluent Python, 2nd Edition</li> <li>Python - Documentation</li> </ul> <p>*and of course chatGPT </p>"},{"location":"basics/control_flow/","title":"Control Flow","text":""},{"location":"basics/operators/","title":"Python Operators","text":""},{"location":"basics/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li>Addition: +</li> <li>Subtraction: -</li> <li>Multiplication: *</li> <li>Division: /</li> <li>Floor Division: //</li> <li>Modulus: %</li> <li>Exponentiation: **</li> </ul> arith_operators.py<pre><code>&gt;&gt;&gt; addition = 123 + 123\n&gt;&gt;&gt; subtraction = 123 - 123\n&gt;&gt;&gt; multi = 123 * 123\n&gt;&gt;&gt; division = 123 / 123\n&gt;&gt;&gt; floor_division = 25 // 5\n&gt;&gt;&gt; print(f\"floor_division by 25/5: {floor_division}\")\n&gt;&gt;&gt; floor_division = 25 // 6\n&gt;&gt;&gt; print(f\"floor_division by 25/6: {floor_division}\")\n&gt;&gt;&gt; modulus = 25 % 5\n&gt;&gt;&gt; print(f\"modulus by 25/5: {modulus}\")\n&gt;&gt;&gt; modulus = 25 % 6\n&gt;&gt;&gt; print(f\"modulus by 25/6: {modulus}\")\n&gt;&gt;&gt; exponentiation = 2 ** 2\n&gt;&gt;&gt; print(f\"exponentiation: {exponentiation}\")\nfloor_division by 25/5: 5\nfloor_division by 25/6: 4\nmodulus by 25/5: 0\nmodulus by 25/6: 1\nexponentiation: 4\n</code></pre>"},{"location":"basics/operators/#assignment-operators","title":"Assignment Operators","text":"<ul> <li>Assignment: =</li> <li>Addition Assignment: +=</li> <li>Subtraction Assignment: -=</li> <li>Multiplication Assignment: *=</li> <li>Division Assignment: /=</li> <li>Floor Division Assignment: //=</li> <li>Modulus Assignment: %=</li> <li>Exponentiation Assignment: **=</li> </ul>"},{"location":"basics/operators/#comparison-operators","title":"Comparison Operators","text":"<ul> <li>Equal to: ==</li> <li>Not equal to: !=</li> <li>Greater than: &gt;</li> <li>Less than: &lt;</li> <li>Greater than or equal to: &gt;=</li> <li>Less than or equal to: &lt;=</li> </ul>"},{"location":"basics/operators/#logical-operators","title":"Logical Operators","text":"<ul> <li>Logical AND: and</li> <li>Logical OR: or</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>Bitwise operators are used to perform operations on individual bits of binary numbers. They treat numbers as sequences of binary digits (bits) and operate on them bit by bit.</p> <ul> <li> <p>Bitwise AND: &amp;</p> <p>Performs a logical AND operation on each pair of corresponding bits. If both bits are 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise OR: |</p> <p>Performs a logical OR operation on each pair of corresponding bits. If at least one bit is 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise XOR: ^</p> <p>Performs a logical XOR (exclusive OR) operation on each pair of corresponding bits. If the two bits are different (one is 0 and the other is 1), the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise NOT: ~</p> <p>Inverts (flips) the bits of a number. Changes each 1 to 0 and each 0 to 1.</p> </li> <li> <p>Left Shift: &lt;&lt;</p> <p>Shifts the bits of a number to the left by a specified number of positions. The empty positions on the right are filled with zeros. Each shift to the left is equivalent to multiplying the number by 2.</p> </li> <li> <p>Right Shift: &gt;&gt;</p> <p>Shifts the bits of a number to the right by a specified number of positions. The empty positions on the left are filled with the sign bit (0 for positive numbers, 1 for negative numbers). Each arithmetic shift to the right is equivalent to dividing the number by 2.</p> </li> </ul> <p>Bitwise operators are commonly used in low-level programming, networking, and manipulation of binary data. They allow you to manipulate individual bits within numbers, set or clear specific flags, or extract information from bit patterns.</p>"},{"location":"basics/operators/#membership-operators","title":"Membership Operators","text":"<ul> <li>In: in</li> <li>Not in: not in</li> </ul>"},{"location":"basics/operators/#identity-operators","title":"Identity Operators","text":"<ul> <li>Is: is</li> <li>Is not: is not</li> </ul>"},{"location":"basics/operators/#unary-operators","title":"Unary Operators","text":"<ul> <li>Positive: +</li> <li>Negative: -</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#ternary-operator","title":"Ternary Operator","text":"<ul> <li>Conditional Expression: a if condition else b</li> </ul> ternary.py<pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 20\n&gt;&gt;&gt; print(a if a &gt; b else b)\n20\n</code></pre>"},{"location":"basics/python_paradigm/","title":"Python's Paradigms and Way of Work","text":"<p>It supports multiple programming paradigms and follows a specific way of working.Python's paradigms encompass dynamic typing, support for object-oriented and functional programming, garbage collection for memory management, emphasis on readability and expressiveness, and a rich standard library. These features contribute to Python's popularity and make it a flexible language for diverse programming needs. Here are some key aspects of Python's paradigms and its way of work:</p> <ul> <li> <p>Dynamic Typing System: Python uses a dynamic typing system, which means you don't need to explicitly declare variable types. You can assign values of different types to the same variable, and Python determines the type during runtime. This flexibility allows for quick prototyping and easy code modification.</p> </li> <li> <p>Object-Oriented Programming (OOP): Python fully supports object-oriented programming. It provides classes, objects, and inheritance, allowing you to create reusable and modular code. Encapsulation, polymorphism, and inheritance are core principles of OOP that Python encourages.</p> </li> <li> <p>Functional Programming: Python also supports functional programming paradigms. Functions are first-class citizens, which means you can assign them to variables, pass them as arguments, and return them as values. Python provides built-in higher-order functions like map, filter, and reduce, making it easier to write functional-style code.</p> </li> <li> <p>Imperative Programming: Python is primarily an imperative programming language. It follows a sequential execution model, where statements are executed in the order they appear. You can use control flow statements like if-else, loops, and switch-case to control the flow of execution.</p> </li> <li> <p>Garbage Collection: Python has an automatic garbage collector that manages memory allocation and deallocation. It frees developers from manual memory management tasks like allocating and releasing memory. The garbage collector identifies unused objects and reclaims the memory occupied by them, making Python memory-efficient.</p> </li> <li> <p>Extensive Standard Library: Python comes with a comprehensive standard library that offers a wide range of modules and functions for various purposes. The standard library provides ready-to-use solutions for common tasks, reducing the need for writing code from scratch. It enables developers to be productive and efficient.</p> </li> </ul>"},{"location":"basics/variables_and_datatypes/","title":"Variables and Data Types","text":"<p>In Python, variables can refer to different types of data, enabling us to manipulate that data as needed. To facilitate this, Python offers a range of standard data types that are specifically designed for storing and manipulating various kinds of data.</p>"},{"location":"basics/variables_and_datatypes/#variables","title":"Variables","text":"<p>One of the most notable and distinct features of variables in Python is their dynamic typing. This means that a single variable can change its type as required during the execution of the program.</p> variables.py<pre><code>&gt;&gt;&gt; nice_var = 123\n&gt;&gt;&gt; print(type(nice_var))\n&gt;&gt;&gt; nice_var = \"now I'm a string\"\n&gt;&gt;&gt; print(type(nice_var))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#data-types","title":"Data Types","text":"<p>Python categorizes data types into the following categories: Text, Numeric, Sequence, Mapping, Set, Boolean, and Binary types. These categories encompass the various types of data that Python can handle.</p>"},{"location":"basics/variables_and_datatypes/#text-type","title":"Text Type","text":"<ul> <li>str: Represents a sequence of characters, such as \"hello\" or \"Python\". Strings are immutable.</li> </ul> text.py<pre><code>&gt;&gt;&gt; string_var = \"Corinthians please help me\"\n&gt;&gt;&gt; print(string_var)\n&gt;&gt;&gt; print(type(string_var))\nCorinthians please help me\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#numeric-type","title":"Numeric Type","text":"<ul> <li>str: Represents integers (whole numbers) like 5, -3, 100.</li> <li>float: Represents floating-point numbers with decimal places like 3.14, -0.5, 2.0.</li> </ul> numeric.py<pre><code>&gt;&gt;&gt; int_number = 1910\n&gt;&gt;&gt; print(int_number)\n&gt;&gt;&gt; print(type(int_number))\n&gt;&gt;&gt; print(int_number + 2)\n&gt;&gt;&gt; float_number = int_number + 0.3\n&gt;&gt;&gt; print(float_number)\n&gt;&gt;&gt; print(type(float_number))\n1910\n&lt;class 'int'&gt;\n1912\n1910.3\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#sequence-type","title":"Sequence Type","text":"<ul> <li>list: Represents an ordered collection of elements enclosed in square brackets ([]). Lists can contain elements of different data types and are mutable, meaning you can modify them.</li> <li>tuple: Similar to lists, tuples represent an ordered collection of elements enclosed in parentheses (()). However, tuples are immutable, meaning they cannot be modified once created.</li> <li>range: Python provides a built-in range() function that generates a sequence of numbers within a specified range. The range() function is commonly used in loops and iterations.</li> </ul> sequence.py<pre><code>&gt;&gt;&gt; my_list = list([1, 2, 3, 4])\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; my_list = [5, 6, 7, 8]\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_tuple = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; my_tuple = tuple((1, 2, 3, 4, 5)) # cannot tuple(1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"Tuple with only one element\")\n&gt;&gt;&gt; my_tuple = (1,) # or tuple((1,))\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_range = range(1, 5)\n&gt;&gt;&gt; for num in my_range:\n&gt;&gt;&gt;     print(f\"num value: {num}\")\n[1, 2, 3, 4]\n&lt;class 'list'&gt;\n[5, 6, 7, 8]\n&lt;class 'list'&gt;\n---------------------------&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\nTuple with only one element\n(1,)\n&lt;class 'tuple'&gt;\n---------------------------&gt;\nnum value: 1\nnum value: 2\nnum value: 3\nnum value: 4\n</code></pre>"},{"location":"basics/variables_and_datatypes/#mapping-type","title":"Mapping Type","text":"<ul> <li>dictionary (dict): Represents a collection of key-value pairs enclosed in curly braces ({}) or created using the dict() constructor. Dictionaries provide a way to store and retrieve data using unique keys.</li> </ul> dict.py<pre><code>&gt;&gt;&gt; my_dict = {\"name\" : \"Gabriel\", \"age\" : 25}\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n&gt;&gt;&gt; my_dict = dict(name=\"Gabriel\", age=25)\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#set-data-types","title":"Set Data Types","text":"<ul> <li>set: Represents an unordered collection of unique elements enclosed in curly braces ({}) or created using the set() constructor. Sets are useful to perform operations like union, intersection, and difference.</li> <li>fronzenset: Similar to set, frozensets are immutable and represent an unordered collection of unique elements. While elements of a set can be modified at any time, elements of the frozen set remain the same after creation.</li> </ul> set.py<pre><code>&gt;&gt;&gt; my_set = set((\"apple\", \"banana\", \"cherry\"))\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; my_set = {5, 6, 7, 8}\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_frozenset = frozenset([1, 2, 3, 4, 5])\n&gt;&gt;&gt; print(my_frozenset)\n&gt;&gt;&gt; print(type(my_frozenset))\n{'apple', 'cherry', 'banana'}\n&lt;class 'set'&gt;\n{8, 5, 6, 7}\n&lt;class 'set'&gt;\n---------------------------&gt;\nfrozenset({1, 2, 3, 4, 5})\n&lt;class 'frozenset'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#boolean-type","title":"Boolean Type","text":"<ul> <li>boll: Represents a logical value indicating either True or False. Boolean values are often the result of comparisons or logical operations.</li> </ul> bool.py<pre><code>&gt;&gt;&gt; my_bool = bool(5)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = bool(0)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = True\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\nTrue\n&lt;class 'bool'&gt;\nFalse\n&lt;class 'bool'&gt;\nTrue\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#binary-types","title":"Binary Types","text":"<ul> <li>bytes: Bytes are immutable sequences of individual bytes. They represent a fixed sequence of bytes that cannot be modified once created. Bytes can be created using literals or by calling the built-in bytes() constructor. They are commonly used to store and process raw binary data.</li> <li>bytearray: Bytearray, unlike bytes, is a mutable sequence of bytes. It allows modifications after creation, such as appending, replacing, or deleting elements. Bytearray objects can be created using literals or by calling the bytearray() constructor. They provide a flexible way to modify binary data.</li> <li>memoryview: Memoryview is a Python object that provides a way to access the internal data of an object (such as bytes or bytearray) without making a copy. It acts as a \"window\" into the data, allowing efficient access and manipulation of large amounts of binary data. Memoryview objects can be created by calling the built-in memoryview() constructor.</li> </ul> binary.py<pre><code>&gt;&gt;&gt; my_bytes = b\"Hello\"\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; my_bytes = bytes(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = bytearray(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = memoryview(bytes(5))\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\nb'Hello'\n&lt;class 'bytes'&gt;\nb'\\x00\\x00\\x00\\x00\\x00'\n&lt;class 'bytes'&gt;\n---------------------------&gt;\nbytearray(b'\\x00\\x00\\x00\\x00\\x00')\n&lt;class 'bytearray'&gt;\n---------------------------&gt;\n&lt;memory at 0x7f5f2ccaa800&gt;\n&lt;class 'memoryview'&gt;\n---------------------------&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#none-type","title":"None Type","text":"<ul> <li>None: Represents a special value indicating the absence of a value. It is commonly used to denote a variable that has not been assigned a value.</li> </ul> none.py<pre><code>&gt;&gt;&gt; my_none = None\n&gt;&gt;&gt; print(my_none)\n&gt;&gt;&gt; print(type(my_none))\nNone\n&lt;class 'NoneType'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#references","title":"References","text":"<ul> <li>W3Schools - Python Data Types</li> </ul>"},{"location":"data_model/","title":"Data Model","text":""}]}