{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Python","text":"<p>A particular but not private repository to centralize all studies about Python and a few famous Python's libraries. It's kind my own documentation about the language. </p>"},{"location":"#python-versions-supported","title":"Python Versions Supported","text":"<ul> <li>Python 3.11 or lower</li> </ul>"},{"location":"#backlog","title":"Backlog","text":"<ul> <li>Python 3.12 news</li> </ul>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>W3Schools - Python</li> <li>Fluent Python, 2nd Edition</li> <li>Python - Documentation</li> </ul> <p>*and of course chatGPT </p>"},{"location":"basics/control_flow/","title":"Control Flow","text":"<p>Listing the fundamental and commonly used control flow structures in Python.</p>"},{"location":"basics/control_flow/#if","title":"if","text":"if.py<pre><code>&gt;&gt;&gt; x = 42\n&gt;&gt;&gt; if x &lt; 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\nMore\n</code></pre>"},{"location":"basics/control_flow/#short-hand-if","title":"Short hand if","text":"short_if.py<pre><code>&gt;&gt;&gt; a = 25\n&gt;&gt;&gt; b = 15\n&gt;&gt;&gt; if a &gt; b: print(\"A is greater than B\")\n&gt;&gt;&gt; print(\"B\") if a &lt;= b else print(\"A\")\nA is greater than B\nA\n</code></pre>"},{"location":"basics/control_flow/#while","title":"while","text":"while.py<pre><code>&gt;&gt;&gt; n = 5\n&gt;&gt;&gt; while n &gt; 1:\n...     print(n)\n...     n = n - 1\n5\n4\n3\n2\n</code></pre>"},{"location":"basics/control_flow/#for","title":"for","text":"for.py<pre><code>&gt;&gt;&gt; words = ['cat', 'window', 'defenestrate']\n&gt;&gt;&gt; for w in words:\n...    print(w, len(w))\ncat 3\nwindow 6\ndefenestrate 12\n</code></pre>"},{"location":"basics/control_flow/#range","title":"range","text":"range.py<pre><code>&gt;&gt;&gt; for i in range(3):\n...    print(i)\n... print(\"range(3)---------&gt;\")\n&gt;&gt;&gt; for i in range(5, 10):\n...    print(i)\n... print(\"range(5, 10)---------&gt;\")\n&gt;&gt;&gt; for i in range(0, 10, 2):\n...    print(i)\n... print(\"range(0, 10, 2)---------&gt;\")\n&gt;&gt;&gt; a = ['Mary', 'had', 'a', 'little', 'lamb']\n&gt;&gt;&gt; for i in range(len(a)):\n...    print(i, a[i])\n... print(\"range(len(a))---------&gt;\")\n0\n1\n2\nrange(3)---------&gt;\n5\n6\n7\n8\n9\nrange(5, 10)---------&gt;\n0\n2\n4\n6\n8\nrange(0, 10, 2)---------&gt;\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\nrange(len(a))---------&gt;\n</code></pre>"},{"location":"basics/control_flow/#try","title":"try","text":"try.py<pre><code>&gt;&gt;&gt; try:\n...    zero_division = 10 / 0\n... except ZeroDivisionError as zero_error:\n...     print(f\"ERROR: {zero_error}\")\n... except:\n...     print(\"Global except clause\")\n... finally:\n...     print(\"Justing print the finally\")\nERROR: division by zero\nJusting print the finally\n</code></pre>"},{"location":"basics/control_flow/#break-continue-and-else-on-loops","title":"break, continue and else on loops","text":"<ul> <li>The break statement breaks out the innermost enclosing for or while loop.</li> <li>The else statement in loops is executed when the loop terminates through exhaustion, but not when the loop is terminated by a break statement.</li> </ul> break_else.py<pre><code>&gt;&gt;&gt; for n in range(2, 10):\n&gt;&gt;&gt;    for x in range(2, n):\n...        if n % x == 0:\n...            print(n, 'equals', x, '*', n//x)\n...            break\n...    else:\n...        # loop fell through without finding a factor\n...        print(n, 'is a prime number')\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n</code></pre> <ul> <li>The continue statement continues with the next iteration of the loop.</li> </ul> continue.py<pre><code>&gt;&gt;&gt; for num in range(2, 10):\n&gt;&gt;&gt;    if num % 2 == 0:\n...        print(\"Found an even number\", num)\n...        continue\n...    print(\"Found an odd number\", num)\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n</code></pre>"},{"location":"basics/control_flow/#match","title":"match","text":"<ul> <li>A match statement takes an exmpression and compares its value to sucessive patterns using the case blocks.</li> <li>This is similar to a switch statement but it's more similiar to patter matching.</li> <li>Only the first pattern that matches gets executed.</li> <li>There are many use cases that will be explorer more in this documentation.</li> </ul> match.py<pre><code>&gt;&gt;&gt; def http_error(status):\n&gt;&gt;&gt;    match status:\n...        case 400:\n...            return \"Bad request\"\n...        case 404:\n...            return \"Not found\"\n...        case 418:\n...            return \"I'm a teapot\"\n...        case _:\n...            return \"Something's wrong with the internet\"\n</code></pre>"},{"location":"basics/control_flow/#references","title":"References","text":"<ul> <li>Python - 8. Compound statements</li> <li>Python - 4. More Control Flow Tools</li> </ul>"},{"location":"basics/exception/","title":"Exception Handling","text":"<p>To ensure consistency and proper handling, all exceptions must be instances of a class that derives from the BaseException class. This principle helps maintain code clarity and enables developers to catch and respond to specific error scenarios effectively.</p>"},{"location":"basics/exception/#handiling-exceptions","title":"Handiling Exceptions","text":""},{"location":"basics/exception/#selected-exception","title":"Selected Exception","text":"selecet_exc.py<pre><code>&gt;&gt;&gt; try:\n...     x = \"hello\"\n...     y = sum(x)\n... except TypeError:\n...     print(\"Operation invalid\")\nOperation invalid\n</code></pre>"},{"location":"basics/exception/#multiple-handlers-expcetions","title":"Multiple Handlers Expcetions","text":"multi_selecet_exc.py<pre><code>&gt;&gt;&gt; try:\n...     x = \"hello\"\n...     z = x / 2\n...     y = sum(x)\n... except (ValueError, TypeError, NameError):\n...     print(\"Operation invalid\")\n...     print()\nOperation invalid\n</code></pre> multi_selecet_exc2.py<pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; try:\n...    f = open('myfile.txt')\n...    s = f.readline()\n...    i = int(s.strip())\n... except OSError as err:\n...    print(\"OS error: {0}\".format(err))\n... except ValueError:\n...    print(\"Could not convert data to an integer.\")\n... except BaseException as err:\n...    print(f\"Unexpected {err=}, {type(err)=}\")\n...    raise\nOS error: [Errno 2] No such file or directory: 'myfile.txt'\n</code></pre>"},{"location":"basics/exception/#baseexceptions-as-a-wildcard","title":"BaseExceptions as a Wildcard","text":"<p>By virtue of all exceptions inheriting from BaseException, it is possible to utilize the \"except\" statement to capture any exception.</p> base_exc.py<pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; try:\n...    f = open('myfile.txt')\n...    s = f.readline()\n...    i = int(s.strip())\n... except BaseException as err:\n...    print(f\"Unexpected {err=}, {type(err)=}\")\nUnexpected err=FileNotFoundError(2, 'No such file or directory'), type(err)=&lt;class 'FileNotFoundError'&gt;\n</code></pre>"},{"location":"basics/exception/#exception-properties-analyses","title":"Exception Properties Analyses","text":"base_exc.py<pre><code>&gt;&gt;&gt; try:\n...    raise Exception('spam', 'eggs')\n... except Exception as inst:\n...    print(type(inst))\n...    print(inst.args)\n...    x, y = inst.args\n...    print('x =', x)\n...    print('y =', y)\n&lt;class 'Exception'&gt;\n('spam', 'eggs')\nx = spam\ny = eggs\n</code></pre>"},{"location":"basics/exception/#raise-exceptions","title":"Raise Exceptions","text":"<pre><code>raise ValueError  # shorthand for 'raise ValueError()'\n</code></pre> <pre><code>try:\nraise NameError('Hi There')\nexcept NameError:\nprint('An exception flew by!')\nraise\n</code></pre>"},{"location":"basics/exception/#exceptions-chaining","title":"Exceptions Chaining","text":"<p>The raise statement in Python enables the option of chaining exceptions, facilitating error handling and flow control within the code.</p> exc_chaning.py<pre><code>&gt;&gt;&gt; def func():\n...    raise ConnectionError\n&gt;&gt;&gt; try:\n...    func()\n... except ConnectionError as exc:\n...    raise RuntimeError('Failed to open database') from exc\n</code></pre> exc_chaning_result.py<pre><code>Traceback (most recent call last):\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 4, in &lt;module&gt;\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"/home/gabriel/Projects/mastering-python/venv/lib/python3.11/site-packages/markdown_exec/formatters/python.py\", line 59, in _run_python\nexec(compiled, exec_globals)  # noqa: S102\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 6, in &lt;module&gt;\nraise RuntimeError('Failed to open database') from exc\nRuntimeError: Failed to open database\n</code></pre>"},{"location":"basics/exception/#user-definied-exceptions","title":"User-definied Exceptions","text":"<p>When creating user-defined exceptions, it is essential to ensure they are derived either directly or indirectly from the built-in Exception class. Conventionally, these custom exceptions are named with endings such as \"Error,\" following a clear and descriptive naming pattern for enhanced code readability.</p> db_exception.py<pre><code>from dataclasses import dataclass, field\n@dataclass\nclass DatabaseConnectionError(Exception):\nmessage: str = field(init=False, default=\"Couldn't connect to database\")\n</code></pre>"},{"location":"basics/exception/#references","title":"References","text":"<ul> <li>Python Exceptions</li> <li>Python Built-in Exceptions</li> <li>Real Python Exceptions</li> </ul>"},{"location":"basics/hashable/","title":"Hashable Objects","text":"<p>An object is hashable if it has a hash code which never changes during its lifetime (it needs a\u00a0<code>__hash__()</code>\u00a0method), and can be compared to other objects (it needs an\u00a0<code>__eq__()</code>\u00a0method). Hashable objects which compare equal must have the same hash code.</p>"},{"location":"basics/hashable/#hashable-types","title":"Hashable Types","text":"<ol> <li><code>Numeric</code> types;</li> <li>Flat immutable1 types <code>str</code> and <code>bytes</code>;</li> <li>Container types1 if the object and all elements are immutable and hashable:<ul> <li><code>FrozenSet</code> are hashable because every element it contains must be hashable by definition;</li> <li>A <code>Tuple</code> is hashable <code>only if all its items are hashable</code>;</li> </ul> </li> </ol>"},{"location":"basics/hashable/#characteristics","title":"Characteristics","text":"<ol> <li>The <code>hash code might vary</code> based on the Python version, machine setup, and the way the hash was created;</li> <li>The hase code is <code>guaranteed to be the same only within one Python process</code>;</li> <li><code>Custom user-defined types are hashable by default</code>. This happens because their hash code is derived from their <code>id()</code>, and the <code>__eq__()</code> method, which is inherited from the object class, simply checks whether the object IDs are the same;</li> <li>If an <code>object implements a custom __eq__()</code> that takes into account its <code>internal state</code>, it will be hashable only if its <code>__hash__() always returns the same hash code</code>:<ul> <li>In practice, this requires that <code>__eq__()</code> and <code>__hash__()</code> only take into account instance attributes that never change during the life of the object</li> </ul> </li> </ol>"},{"location":"basics/hashable/#code","title":"Code","text":"hashable_obj.py<pre><code>&gt;&gt;&gt; tt = (1, 2, (30, 40))\n&gt;&gt;&gt; print(hash(tt))\n&gt;&gt;&gt; tl = (1, 2, [30, 40])\n&gt;&gt;&gt; try:\n...     hash(tl)\n... except BaseException as ex:\n...     print(f\"Hash error when use unhashable obj: {ex}\")\n&gt;&gt;&gt; tf = (1, 2, frozenset([30, 40]))\n&gt;&gt;&gt; print(hash(tf))\n-3907003130834322577\nHash error when use unhashable obj: unhashable type: 'list'\n5149391500123939311\n</code></pre>"},{"location":"basics/hashable/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul> <ol> <li> <p>Flat vs Container debate \u21a9\u21a9</p> </li> </ol>"},{"location":"basics/modules_packages/","title":"Modules and Packages","text":""},{"location":"basics/modules_packages/#modules","title":"Modules","text":"<p>In Python, a module is essentially a file that contains various definitions and statements. The module name corresponds to the file name without the .py extension. Within a module, the module's name (as a string) is available as the value of the global variable <code>__name__</code>.</p> <p>When importing modules, if the imported module names are placed at the top level of a file (outside any function or class), they are added to the module's global namespace. This allows easy access to the functions, variables, or classes defined within the imported modules.</p> <p>In addition to Python-written modules, you can also define a folder as a module by including a file called init.py within it. This folder then becomes a module that can be imported and utilized.</p> modules.py<pre><code># import module 'dataclasses' to current namespaces\nimport dataclasses\n# import names (dataclass, field) to current namespaces\nfrom dataclasses import dataclass, field \n# import all names from the module,\n# except those beginning with underscore on the name\nfrom dataclasses import *\n</code></pre>"},{"location":"basics/modules_packages/#absolute-imports","title":"Absolute imports","text":"<p>An absolute import refers to a type of import where the location of the classes being imported is fully specified. This allows for a clear and unambiguous reference to the desired import location, ensuring that there is no confusion or conflict with other modules or classes that may have the same name but reside in different packages or directories.</p> abs_import.py<pre><code># from PACKAGE.MODULE.MODULE import CLASS\nfrom pandas.core.frame import DataFrame\n# import PACKAGE.MODULE.MODULE\nimport pandas.core.frame as frame\nexample = frame.DataFrame()\n# from PACKAGE.MODULE import MODULE \nfrom pandas.core import frame\n</code></pre>"},{"location":"basics/modules_packages/#relative-imports","title":"Relative imports","text":"<p>Relative imports allow us to specify the location of the classes being imported relative to the current package or module. By using relative import statements, we can reference and import classes from modules located within the same package or subpackages, providing a concise and context-aware way to import and utilize code within the project's structure.</p> <ul> <li>Current directory: <code>.</code></li> <li>Previous directory: <code>..</code></li> </ul> <pre>\n\u2514\u2500\u2500 not_nice_import.py\n    \u251c\u2500\u2500 relative_import.py\n    \u251c\u2500\u2500 nice_file.py\n</pre> relative_import.py<pre><code># if the files are in the same place\nfrom .nice_file import add_func\n# if the file calling is one directory down\nfrom ..not_nice_import import not_nice_add_func\n</code></pre>"},{"location":"basics/modules_packages/#impact-of-init-file","title":"Impact of init file","text":"<pre>\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 calculator_func\n        \u251c\u2500\u2500 __init_.py\n        \u251c\u2500\u2500 add_func.py\n        \u251c\u2500\u2500 sub_func.py\n        \u251c\u2500\u2500 mul_func.py\n        \u251c\u2500\u2500 div_func.py\n    \u251c\u2500\u2500 calculator.py\n</pre> __init__.py<pre><code>from .add_func import add_func\nfrom .sub_func import sub_func\nfrom .mul_func import mul_func\nfrom .div_func import div_func\n</code></pre> calculator.py<pre><code># instead of\nfrom calculator_func.add_func import add_func\nfrom calculator_func.sub_func import sub_func\n# possible to import\nfrom calculator_func import add_func, sub_func, mul_func, div_func\n</code></pre>"},{"location":"basics/modules_packages/#executing-modules-as-scripts","title":"Executing modules as scripts","text":"<p>In Python, any file that contains a module is also considered a Python script and can be executed when imported. However, by including the following code block, it prevents the module from executing when imported, allowing the file to be used both as a standalone script and as an importable module:</p> import_main.py<pre><code>if __name__ == \"__main__\":\n# Code to be executed when the script is run directly\npass\n</code></pre> <p>This usage of the <code>__name__</code> variable ensures that the code block under the if statement is only executed when the file is run directly as a script, rather than being imported as a module. This distinction allows the file to serve dual purposes, functioning as an executable script or an importable module based on how it is invoked.</p>"},{"location":"basics/modules_packages/#packages","title":"Packages","text":"<p>In Python, a package is a collection of modules that enables hierarchical structuring of the module namespace using dot notation. They help prevent naming collisions between modules by providing a way to create a nested structure for modules. Similar to how modules mitigate conflicts in global variable names, packages ensure that module names remain distinct and avoid clashes within the project's namespace. This hierarchical organization enhances code readability, maintainability, and reduces the risk of naming conflicts.</p>"},{"location":"basics/modules_packages/#difference-when-use-from-and-import","title":"Difference when use <code>from</code> and <code>import</code>","text":"from_import.py<pre><code># item can be either a submodule, or some other name defined in the package,\n# like a function, class or variable\nfrom package import item\n# item MUST BE a package. subitem can be a module or a package\n# but can't be a class or function\nimport package.item.subitem\n</code></pre>"},{"location":"basics/modules_packages/#importing-from-a-package","title":"Importing * from a Package","text":"<p>Importing everything using the <code>*</code> notation in Python packages can lead to lengthy import times and unintended side effects. It is generally not recommended to import all modules from a package in this manner. However, you can specify which modules should be imported when using <code>from package import *</code>, you can define a list named <code>__all__</code> in the <code>__init__</code>.py file of the package.</p> __init__with_all.py<pre><code>from .add_func import add_func\nfrom .sub_func import sub_func\nfrom .mul_func import mul_func\nfrom .div_func import div_func\n__all__ = [\n\"add_func\",\n\"sub_func\",\n\"mul_func\",\n\"div_func\",\n]\n</code></pre>"},{"location":"basics/modules_packages/#references","title":"References","text":"<ul> <li>Python Modules doc</li> <li>Real Python Modules and Packages</li> </ul>"},{"location":"basics/object_handling/","title":"Object References, Mutability, and Recycling","text":""},{"location":"basics/object_handling/#variables-references","title":"Variables references","text":"<p>In Python, variables serve as labels that refer to objects stored in memory. It's important to understand that an object can have multiple labels assigned to it, creating a form of aliasing. Instead of saying that an object is assigned to a variable, it is more accurate and meaningful to say that a variable is assigned to an object. This shift in perspective acknowledges that the object exists before the assignment takes place, clarifying the relationship between variables and objects.</p> <p>If a variable changes the value of an object, all other variables assigned to the same object will reflect that change as well.</p> var_ref.py<pre><code>&gt;&gt;&gt; a = [1, 2, 3] \n&gt;&gt;&gt; b = a          \n&gt;&gt;&gt; a.append(4)    \n&gt;&gt;&gt; print(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n</code></pre> <p></p>"},{"location":"basics/object_handling/#identity-and-equality","title":"Identity and Equality","text":"<p>In Python, variables that refer to the same object have the same identity and values. Any changes made to the object through one variable will be reflected when accessing it through the other variable.</p> <p>On the other hand, if two different objects are created with the same values, they will have different identities. This is because each object occupies a distinct location in memory, even though their values may be the same. It's important to note that equality of values does not imply identity. Each object has its own unique identity, regardless of the similarity of their values.</p> identity_equality.py<pre><code>&gt;&gt;&gt; charles = {'name': 'Charles L. Dodgson', 'born': 1832}\n&gt;&gt;&gt; lewis = charles  \n&gt;&gt;&gt; print(f\"Lewis is charles? {lewis is charles}\")\n&gt;&gt;&gt; print(f\"Charles id: {id(charles)}, Lewis id: {id(lewis)}\")\n&gt;&gt;&gt; lewis['balance'] = 950  \n&gt;&gt;&gt; print(f\"Charles with balance property also {charles}\")\n&gt;&gt;&gt; alex = {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}\n&gt;&gt;&gt; print(f\"Alex == Charles? {alex == charles}\")\n&gt;&gt;&gt; print(f\"Alex is Charles? {alex is charles}\")\nLewis is charles? True\nCharles id: 139875386178240, Lewis id: 139875386178240\nCharles with balance property also {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}\nAlex == Charles? True\nAlex is Charles? False\n</code></pre>"},{"location":"basics/object_handling/#choosing-between-and-is","title":"Choosing between <code>==</code> and <code>is</code>","text":"<p>In Python, the == operator is used to compare the values of objects, evaluating whether they hold the same data. On the other hand, the is operator compares the identities of objects, determining if they refer to the same underlying object in memory.</p> <p>The is operator is generally faster than == because it cannot be overloaded. Since it is not subject to method invocations, Python can directly compare the integer IDs of the objects, making the evaluation process straightforward and efficient. In contrast, when using the == operator, Python invokes the <code>__eq__()</code> special method to compare the values of objects. This syntactic sugar allows for more flexible value comparisons and supports custom equality behavior defined by the objects' classes.</p>"},{"location":"basics/object_handling/#copying-objects","title":"Copying objects","text":"<p>In Python, there are two types of object copying: deep copy and shallow copy.</p> <p>A deep copy creates a completely independent duplicate of an object, including any nested objects it may contain. This means that the duplicate object and its nested objects do not share any references with the original object. Any modifications made to the duplicate will not affect the original object or its nested objects.</p> <p>On the other hand, a shallow copy creates a new object that shares some references with the original object. It essentially creates a new object with a separate identity, but certain internal references are still shared. This means that changes made to the shallow copy may impact the original object or its nested objects, as they are still connected through shared references.</p> <p>By default, Python performs shallow copies when creating copies of objects. However, it's important to note that some built-in data types, such as numbers and strings, are immutable, and creating copies of them behaves like a deep copy, as there are no nested mutable objects to share references with.</p> copy.py<pre><code>&gt;&gt;&gt; l1 = [3, [66, 55, 44], (7, 8, 9)]\n&gt;&gt;&gt; l2 = list(l1)\n&gt;&gt;&gt; print(f\"l1 == l2? {l1 == l2}\")\n&gt;&gt;&gt; print(f\"l1 is l2? {l1 is l2}\")\n&gt;&gt;&gt; print(f\"l1 id: {id(l1)}, l2 id: {id(l2)}\")\n&gt;&gt;&gt; l1.append(100)\n&gt;&gt;&gt; print(\"You can change l1 just fine, without changing l2: \")\n&gt;&gt;&gt; print(l1)\n&gt;&gt;&gt; print(l2)\n&gt;&gt;&gt; print(\"However, when you change l1[1], and l2[1] which is a list and mutable\")\n&gt;&gt;&gt; l1[1].remove(55)   \n&gt;&gt;&gt; l2[1] += [33, 22]  \n&gt;&gt;&gt; l2[2] += (10, 11)\n&gt;&gt;&gt; print(l1)\n&gt;&gt;&gt; print(l2)\nl1 == l2? True\nl1 is l2? False\nl1 id: 139875387989888, l2 id: 139875386509440\nYou can change l1 just fine, without changing l2: \n[3, [66, 55, 44], (7, 8, 9), 100]\n[3, [66, 55, 44], (7, 8, 9)]\nHowever, when you change l1[1], and l2[1] which is a list and mutable\n[3, [66, 44, 33, 22], (7, 8, 9), 100]\n[3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]\n</code></pre> <p>In Python, you have the ability to customize the behavior of copying objects by implementing the <code>__copy__()</code> and <code>__deepcopy__()</code> special methods.</p> <p>The <code>__copy__()</code> method allows you to define how an object should be shallow copied. By overriding this method in your class, you can specify the exact behavior you desire when creating a shallow copy of an instance. Similarly, the <code>__deepcopy__()</code> method allows you to define the behavior for deep copying an object. By implementing this method, you can control how the object and its nested objects should be duplicated to create an independent deep copy.</p>"},{"location":"basics/object_handling/#command-del-and-garbage-collection","title":"Command <code>del</code> and Garbage Collection","text":"<p>Objects\u00a0are never explicitly destroyed; however, when they become unreachable they may be garbage-collected.</p> <p>The <code>del</code>\u00a0is that it\u2019s not a function, it\u2019s a statement. del\u00a0deletes references, not objects. Python\u2019s garbage collector may discard an object from memory as an indirect result of\u00a0del, if the deleted variable was the last reference to the object. In CPython, the primary algorithm for garbage collection is\u00a0reference counting.</p> del.py<pre><code>&gt;&gt;&gt; a = [1, 2]  \n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; print(id(a), id(b))\n&gt;&gt;&gt; del a\n&gt;&gt;&gt; print(b)\n&gt;&gt;&gt; print(\"Rebinding b to a different object, removing the last remaining reference to [1, 2]\")\n&gt;&gt;&gt; b = [3]\n&gt;&gt;&gt; print(id(b))\n&gt;&gt;&gt; print(\"Now the garbage collector can discard that object.\")\n139875386399616 139875386399616\n[1, 2]\nRebinding b to a different object, removing the last remaining reference to [1, 2]\n139875386403136\nNow the garbage collector can discard that object.\n</code></pre>"},{"location":"basics/object_handling/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"basics/operators/","title":"Python Operators","text":""},{"location":"basics/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li>Addition: +</li> <li>Subtraction: -</li> <li>Multiplication: *</li> <li>Division: /</li> <li>Floor Division: //</li> <li>Modulus: %</li> <li>Exponentiation: **</li> </ul> arith_operators.py<pre><code>&gt;&gt;&gt; addition = 123 + 123\n&gt;&gt;&gt; subtraction = 123 - 123\n&gt;&gt;&gt; multi = 123 * 123\n&gt;&gt;&gt; division = 123 / 123\n&gt;&gt;&gt; floor_division = 25 // 5\n&gt;&gt;&gt; print(f\"floor_division by 25/5: {floor_division}\")\n&gt;&gt;&gt; floor_division = 25 // 6\n&gt;&gt;&gt; print(f\"floor_division by 25/6: {floor_division}\")\n&gt;&gt;&gt; modulus = 25 % 5\n&gt;&gt;&gt; print(f\"modulus by 25/5: {modulus}\")\n&gt;&gt;&gt; modulus = 25 % 6\n&gt;&gt;&gt; print(f\"modulus by 25/6: {modulus}\")\n&gt;&gt;&gt; exponentiation = 2 ** 2\n&gt;&gt;&gt; print(f\"exponentiation: {exponentiation}\")\nfloor_division by 25/5: 5\nfloor_division by 25/6: 4\nmodulus by 25/5: 0\nmodulus by 25/6: 1\nexponentiation: 4\n</code></pre>"},{"location":"basics/operators/#assignment-operators","title":"Assignment Operators","text":"<ul> <li>Assignment: =</li> <li>Addition Assignment: +=</li> <li>Subtraction Assignment: -=</li> <li>Multiplication Assignment: *=</li> <li>Division Assignment: /=</li> <li>Floor Division Assignment: //=</li> <li>Modulus Assignment: %=</li> <li>Exponentiation Assignment: **=</li> </ul>"},{"location":"basics/operators/#comparison-operators","title":"Comparison Operators","text":"<ul> <li>Equal to: ==</li> <li>Not equal to: !=</li> <li>Greater than: &gt;</li> <li>Less than: &lt;</li> <li>Greater than or equal to: &gt;=</li> <li>Less than or equal to: &lt;=</li> </ul>"},{"location":"basics/operators/#logical-operators","title":"Logical Operators","text":"<ul> <li>Logical AND: and</li> <li>Logical OR: or</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>Bitwise operators are used to perform operations on individual bits of binary numbers. They treat numbers as sequences of binary digits (bits) and operate on them bit by bit.</p> <ul> <li> <p>Bitwise AND: &amp;</p> <p>Performs a logical AND operation on each pair of corresponding bits. If both bits are 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise OR: |</p> <p>Performs a logical OR operation on each pair of corresponding bits. If at least one bit is 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise XOR: ^</p> <p>Performs a logical XOR (exclusive OR) operation on each pair of corresponding bits. If the two bits are different (one is 0 and the other is 1), the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise NOT: ~</p> <p>Inverts (flips) the bits of a number. Changes each 1 to 0 and each 0 to 1.</p> </li> <li> <p>Left Shift: &lt;&lt;</p> <p>Shifts the bits of a number to the left by a specified number of positions. The empty positions on the right are filled with zeros. Each shift to the left is equivalent to multiplying the number by 2.</p> </li> <li> <p>Right Shift: &gt;&gt;</p> <p>Shifts the bits of a number to the right by a specified number of positions. The empty positions on the left are filled with the sign bit (0 for positive numbers, 1 for negative numbers). Each arithmetic shift to the right is equivalent to dividing the number by 2.</p> </li> </ul> <p>Bitwise operators are commonly used in low-level programming, networking, and manipulation of binary data. They allow you to manipulate individual bits within numbers, set or clear specific flags, or extract information from bit patterns.</p>"},{"location":"basics/operators/#membership-operators","title":"Membership Operators","text":"<ul> <li>In: in</li> <li>Not in: not in</li> </ul>"},{"location":"basics/operators/#identity-operators","title":"Identity Operators","text":"<ul> <li>Is: is</li> <li>Is not: is not</li> </ul>"},{"location":"basics/operators/#unary-operators","title":"Unary Operators","text":"<ul> <li>Positive: +</li> <li>Negative: -</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#ternary-operator","title":"Ternary Operator","text":"<ul> <li>Conditional Expression: a if condition else b</li> </ul> ternary.py<pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 20\n&gt;&gt;&gt; print(a if a &gt; b else b)\n20\n</code></pre>"},{"location":"basics/python_paradigm/","title":"Python's Paradigms and Way of Work","text":"<p>It supports multiple programming paradigms and follows a specific way of working.Python's paradigms encompass dynamic typing, support for object-oriented and functional programming, garbage collection for memory management, emphasis on readability and expressiveness, and a rich standard library. These features contribute to Python's popularity and make it a flexible language for diverse programming needs. Here are some key aspects of Python's paradigms and its way of work:</p> <ul> <li> <p>Dynamic Typing System: Python uses a dynamic typing system, which means you don't need to explicitly declare variable types. You can assign values of different types to the same variable, and Python determines the type during runtime. This flexibility allows for quick prototyping and easy code modification.</p> </li> <li> <p>Object-Oriented Programming (OOP): Python fully supports object-oriented programming. It provides classes, objects, and inheritance, allowing you to create reusable and modular code. Encapsulation, polymorphism, and inheritance are core principles of OOP that Python encourages.</p> </li> <li> <p>Functional Programming: Python also supports functional programming paradigms. Functions are first-class citizens, which means you can assign them to variables, pass them as arguments, and return them as values. Python provides built-in higher-order functions like map, filter, and reduce, making it easier to write functional-style code.</p> </li> <li> <p>Imperative Programming: Python is primarily an imperative programming language. It follows a sequential execution model, where statements are executed in the order they appear. You can use control flow statements like if-else, loops, and switch-case to control the flow of execution.</p> </li> <li> <p>Garbage Collection: Python has an automatic garbage collector that manages memory allocation and deallocation. It frees developers from manual memory management tasks like allocating and releasing memory. The garbage collector identifies unused objects and reclaims the memory occupied by them, making Python memory-efficient.</p> </li> <li> <p>Extensive Standard Library: Python comes with a comprehensive standard library that offers a wide range of modules and functions for various purposes. The standard library provides ready-to-use solutions for common tasks, reducing the need for writing code from scratch. It enables developers to be productive and efficient.</p> </li> </ul>"},{"location":"basics/variables_and_datatypes/","title":"Variables and Data Types","text":"<p>In Python, variables can refer to different types of data, enabling us to manipulate that data as needed. To facilitate this, Python offers a range of standard data types that are specifically designed for storing and manipulating various kinds of data.</p>"},{"location":"basics/variables_and_datatypes/#variables","title":"Variables","text":"<p>One of the most notable and distinct features of variables in Python is their dynamic typing. This means that a single variable can change its type as required during the execution of the program.</p> variables.py<pre><code>&gt;&gt;&gt; nice_var = 123\n&gt;&gt;&gt; print(type(nice_var))\n&gt;&gt;&gt; nice_var = \"now I'm a string\"\n&gt;&gt;&gt; print(type(nice_var))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#data-types","title":"Data Types","text":"<p>Python categorizes data types into the following categories: Text, Numeric, Sequence, Mapping, Set, Boolean, and Binary types. These categories encompass the various types of data that Python can handle.</p>"},{"location":"basics/variables_and_datatypes/#text-type","title":"Text Type","text":"<ul> <li>str: Represents a sequence of characters, such as \"hello\" or \"Python\". Strings are immutable.</li> </ul> text.py<pre><code>&gt;&gt;&gt; string_var = \"Corinthians please help me\"\n&gt;&gt;&gt; print(string_var)\n&gt;&gt;&gt; print(type(string_var))\nCorinthians please help me\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#numeric-type","title":"Numeric Type","text":"<ul> <li>str: Represents integers (whole numbers) like 5, -3, 100.</li> <li>float: Represents floating-point numbers with decimal places like 3.14, -0.5, 2.0.</li> </ul> numeric.py<pre><code>&gt;&gt;&gt; int_number = 1910\n&gt;&gt;&gt; print(int_number)\n&gt;&gt;&gt; print(type(int_number))\n&gt;&gt;&gt; print(int_number + 2)\n&gt;&gt;&gt; float_number = int_number + 0.3\n&gt;&gt;&gt; print(float_number)\n&gt;&gt;&gt; print(type(float_number))\n1910\n&lt;class 'int'&gt;\n1912\n1910.3\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#sequence-type","title":"Sequence Type","text":"<ul> <li>list: Represents an ordered collection of elements enclosed in square brackets ([]). Lists can contain elements of different data types and are mutable, meaning you can modify them.</li> <li>tuple: Similar to lists, tuples represent an ordered collection of elements enclosed in parentheses (()). However, tuples are immutable, meaning they cannot be modified once created.</li> <li>range: Python provides a built-in range() function that generates a sequence of numbers within a specified range. The range() function is commonly used in loops and iterations.</li> </ul> sequence.py<pre><code>&gt;&gt;&gt; my_list = list([1, 2, 3, 4])\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; my_list = [5, 6, 7, 8]\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_tuple = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; my_tuple = tuple((1, 2, 3, 4, 5)) # cannot tuple(1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"Tuple with only one element\")\n&gt;&gt;&gt; my_tuple = (1,) # or tuple((1,))\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_range = range(1, 5)\n&gt;&gt;&gt; for num in my_range:\n&gt;&gt;&gt;     print(f\"num value: {num}\")\n[1, 2, 3, 4]\n&lt;class 'list'&gt;\n[5, 6, 7, 8]\n&lt;class 'list'&gt;\n---------------------------&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\nTuple with only one element\n(1,)\n&lt;class 'tuple'&gt;\n---------------------------&gt;\nnum value: 1\nnum value: 2\nnum value: 3\nnum value: 4\n</code></pre>"},{"location":"basics/variables_and_datatypes/#mapping-type","title":"Mapping Type","text":"<ul> <li>dictionary (dict): Represents a collection of key-value pairs enclosed in curly braces ({}) or created using the dict() constructor. Dictionaries provide a way to store and retrieve data using unique keys.</li> </ul> dict.py<pre><code>&gt;&gt;&gt; my_dict = {\"name\" : \"Gabriel\", \"age\" : 25}\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n&gt;&gt;&gt; my_dict = dict(name=\"Gabriel\", age=25)\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#set-data-types","title":"Set Data Types","text":"<ul> <li>set: Represents an unordered collection of unique elements enclosed in curly braces ({}) or created using the set() constructor. Sets are useful to perform operations like union, intersection, and difference.</li> <li>fronzenset: Similar to set, frozensets are immutable and represent an unordered collection of unique elements. While elements of a set can be modified at any time, elements of the frozen set remain the same after creation.</li> </ul> set.py<pre><code>&gt;&gt;&gt; my_set = set((\"apple\", \"banana\", \"cherry\"))\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; my_set = {5, 6, 7, 8}\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_frozenset = frozenset([1, 2, 3, 4, 5])\n&gt;&gt;&gt; print(my_frozenset)\n&gt;&gt;&gt; print(type(my_frozenset))\n{'cherry', 'banana', 'apple'}\n&lt;class 'set'&gt;\n{8, 5, 6, 7}\n&lt;class 'set'&gt;\n---------------------------&gt;\nfrozenset({1, 2, 3, 4, 5})\n&lt;class 'frozenset'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#boolean-type","title":"Boolean Type","text":"<ul> <li>boll: Represents a logical value indicating either True or False. Boolean values are often the result of comparisons or logical operations.</li> </ul> bool.py<pre><code>&gt;&gt;&gt; my_bool = bool(5)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = bool(0)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = True\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\nTrue\n&lt;class 'bool'&gt;\nFalse\n&lt;class 'bool'&gt;\nTrue\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#binary-types","title":"Binary Types","text":"<ul> <li>bytes: Bytes are immutable sequences of individual bytes. They represent a fixed sequence of bytes that cannot be modified once created. Bytes can be created using literals or by calling the built-in bytes() constructor. They are commonly used to store and process raw binary data.</li> <li>bytearray: Bytearray, unlike bytes, is a mutable sequence of bytes. It allows modifications after creation, such as appending, replacing, or deleting elements. Bytearray objects can be created using literals or by calling the bytearray() constructor. They provide a flexible way to modify binary data.</li> <li>memoryview: Memoryview is a Python object that provides a way to access the internal data of an object (such as bytes or bytearray) without making a copy. It acts as a \"window\" into the data, allowing efficient access and manipulation of large amounts of binary data. Memoryview objects can be created by calling the built-in memoryview() constructor.</li> </ul> binary.py<pre><code>&gt;&gt;&gt; my_bytes = b\"Hello\"\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; my_bytes = bytes(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = bytearray(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = memoryview(bytes(5))\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\nb'Hello'\n&lt;class 'bytes'&gt;\nb'\\x00\\x00\\x00\\x00\\x00'\n&lt;class 'bytes'&gt;\n---------------------------&gt;\nbytearray(b'\\x00\\x00\\x00\\x00\\x00')\n&lt;class 'bytearray'&gt;\n---------------------------&gt;\n&lt;memory at 0x7f3746ba6740&gt;\n&lt;class 'memoryview'&gt;\n---------------------------&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#none-type","title":"None Type","text":"<ul> <li>None: Represents a special value indicating the absence of a value. It is commonly used to denote a variable that has not been assigned a value.</li> </ul> none.py<pre><code>&gt;&gt;&gt; my_none = None\n&gt;&gt;&gt; print(my_none)\n&gt;&gt;&gt; print(type(my_none))\nNone\n&lt;class 'NoneType'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#references","title":"References","text":"<ul> <li>W3Schools - Python Data Types</li> </ul>"},{"location":"builtin_modules_examples/functools_module/","title":"Functools Module","text":"<p>The\u00a0<code>functools</code>\u00a0module provides several higher-order functions.</p>"},{"location":"builtin_modules_examples/functools_module/#functoolscache","title":"functools.cache","text":"<p>Python &gt;= 3.9, Python &lt; 3.9 use lru_cache</p> <p>Related with:</p> <ul> <li>Decorators</li> </ul> <p><code>Implements memoization</code>, which is an optimization technique that <code>saves the results of previous invocations of an expensive function</code>. This <code>avoids redundant computations when the function is called with the same arguments again</code>.</p> <p><code>All the arguments taken by the decorated function must be hashable</code>. To save the results of previous calls, a dictionary object is used, where the keys are generated from the positional and keyword arguments used in the calls.</p> <p><code>Really good in applications that need to fetch information from remote APIs.</code></p> cache.py<pre><code>&gt;&gt;&gt; from functools import cache\n&gt;&gt;&gt; @cache\n&gt;&gt;&gt; def fibonacci(n):\n...     if n &lt; 2:\n...         return n\n...     return fibonacci(n - 2) + fibonacci(n - 1)\n</code></pre>"},{"location":"builtin_modules_examples/functools_module/#functoolslru_cache","title":"functools.lru_cache","text":"<p>The main advantage of lru_cache compared to cache is that <code>lru_cache will retain at most 128 entries at any given time</code>. The acronym LRU stands for Least Recently Used, indicating that <code>older entries that haven't been accessed for a while are removed to create space for new ones</code>.</p> lru_cache.py<pre><code>&gt;&gt;&gt; from functools import cache\n&gt;&gt;&gt; @lru_cache\n&gt;&gt;&gt; def fibonacci(n):\n...     if n &lt; 2:\n...         return n\n...     return fibonacci(n - 2) + fibonacci(n - 1)\n</code></pre>"},{"location":"builtin_modules_examples/functools_module/#functoolssingledispatch","title":"functools.singledispatch","text":"<p>In brief, it's a decorator used to <code>establish polymorphism/overloaded functions</code>. It permits various modules to contribute to the overall solution and enables you to easily <code>supply specialized functions, even for types from third-party packages that you can't modify</code>. The function adorned with <code>@singledispatch</code> serves as the entry point for a generic function.</p> <p><code>The function that gets executed depends on the type of the first argument</code> provided at runtime. The <code>names of the specialized functions don't matter</code>; using <code>_</code> is a good choice to make this clear.  <code>If you can't or don't want to add type hints to the decorated function, you can pass a type to the @\u00abbase\u00bb.register decorator.</code></p> <p><code>Whenever possible, register specialized functions to handle Abstract Base Classes (ABCs)</code> like numbers.Integral and abc.MutableSequence. This allows your code to support a wider range of compatible types.</p> <p>An important feature of the singledispatch mechanism is that <code>you can register specialized functions anywhere in your system, in any module</code>. You can create custom functions for classes you didn't write and can't modify.</p> singledispatch.py<pre><code>&gt;&gt;&gt; from functools import singledispatch\n... ...\n&gt;&gt;&gt; @singledispatch\n&gt;&gt;&gt; def nice_add(num1: int, num2: int):\n...     print(\"INT DEFAULT nice_add\")\n...     return num1 + num2\n... ...\n&gt;&gt;&gt; @nice_add.register\n&gt;&gt;&gt; def _(num1: float, num2: float):\n...     print(\"FLOAT nice_add\")\n...     return num1 + num2\n... ...\n&gt;&gt;&gt; @nice_add.register(str)\n&gt;&gt;&gt; def _(num1, num2):\n...     print(\"STRING nice_add\")\n...     return int(num1) + int(num2)\n... ...\n&gt;&gt;&gt; nice_add(1, 2)\n&gt;&gt;&gt; nice_add(1.2, 2.5)\n&gt;&gt;&gt; nice_add(\"1\", \"2\")\nINT DEFAULT nice_add\nFLOAT nice_add\nSTRING nice_add\n</code></pre>"},{"location":"builtin_modules_examples/functools_module/#functoolspartial","title":"functools.partial","text":"<p>Given a callable, it produces a new callable with some of the arguments of the original <code>callable bound to predetermined values</code>. <code>partial</code>\u00a0takes a callable as first argument, followed by an arbitrary number of positional and keyword arguments to bind. The\u00a0<code>functools.partialmethod</code>\u00a0function does the same job as\u00a0partial, but is designed to work with <code>methods</code>.</p> lambda.py<pre><code>&gt;&gt;&gt; from operator import mul\n&gt;&gt;&gt; from functools import partial\n&gt;&gt;&gt; triple = partial(mul, 3)\n&gt;&gt;&gt; print(triple(7))\n&gt;&gt;&gt; result = list(map(triple, range(1, 10)))\n&gt;&gt;&gt; print(result)\n21\n[3, 6, 9, 12, 15, 18, 21, 24, 27]\n</code></pre>"},{"location":"builtin_modules_examples/functools_module/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Functools \u2014 Higher-order functions and operations on callable objects</li> </ul>"},{"location":"builtin_modules_examples/operator_module/","title":"Operator Module","text":"<p>The <code>operator</code> module provides functions equivalents for dozens of operators so you don\u2019t have to code trivial function like <code>lambda a, b: a*b.</code></p>"},{"location":"builtin_modules_examples/operator_module/#operatormul","title":"operator.mul","text":"<p>Multiplication operator.</p> mul_operator.py<pre><code>&gt;&gt;&gt; def factorial(n):\n...    return reduce(lambda a, b: a*b, range(1, n+1))\n&gt;&gt;&gt; \n&gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; from operator import mul\n&gt;&gt;&gt; def factorial(n):\n...    return reduce(mul, range(1, n+1))\n</code></pre>"},{"location":"builtin_modules_examples/operator_module/#operatoritemgetter-and-operatorattrgetter","title":"operator.itemgetter and operator.attrgetter","text":"<p><code>itemgetter</code> and <code>attrgetter</code> are factories that pick items from sequences or read attributes from object.</p> <p><code>itemgetter</code> uses the <code>[]</code> operator, it supports not only sequences but also mappings and any class that implements <code>__getitem__</code>;</p> itemgetter.py<pre><code>&gt;&gt;&gt; metro_data = [\n...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...     ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n&gt;&gt;&gt; from operator import itemgetter\n&gt;&gt;&gt; for city in sorted(metro_data, key=itemgetter(1)):\n...     print(city)\n&gt;&gt;&gt; cc_name = itemgetter(1, 0)\n&gt;&gt;&gt; for city in metro_data:\n...     print(cc_name(city))\n('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833))\n('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889))\n('Mexico City', 'MX', 20.142, (19.433333, -99.133333))\n('IN', 'Delhi NCR')\n('MX', 'Mexico City')\n('BR', 'S\u00e3o Paulo')\n</code></pre> <p><code>attrgetter</code> creates functions to <code>extract object attributes by name</code>. <code>attrgetter</code> can navigate through nested objects that contains a .(dot), to retrieve the attribute.</p> attrgetter.py<pre><code>&gt;&gt;&gt; metro_data = [\n...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...     ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n... ...\n&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; LatLon = namedtuple('LatLon', 'lat lon')  \n&gt;&gt;&gt; Metropolis = namedtuple('Metropolis', 'name cc pop coord')  \n&gt;&gt;&gt; metro_areas = [Metropolis(name, cc, pop, LatLon(lat, lon))  \n...     for name, cc, pop, (lat, lon) in metro_data]\n&gt;&gt;&gt; print(metro_areas[0])\n&gt;&gt;&gt; from operator import attrgetter\n&gt;&gt;&gt; name_lat = attrgetter('name', 'coord.lat') \n&gt;&gt;&gt; for city in sorted(metro_areas, key=attrgetter('coord.lat')):  \n...     print(name_lat(city))\nMetropolis(name='Delhi NCR', cc='IN', pop=21.935, coord=LatLon(lat=28.613889, lon=77.208889))\n('S\u00e3o Paulo', -23.547778)\n('Mexico City', 19.433333)\n('Delhi NCR', 28.613889)\n</code></pre>"},{"location":"builtin_modules_examples/operator_module/#operatormethodcaller","title":"operator.methodcaller","text":"<p>Creates a function that calls a method by name on the object  given as argument.</p> lambda.py<pre><code>&gt;&gt;&gt; from operator import methodcaller\n&gt;&gt;&gt; s = 'The time has come'\n&gt;&gt;&gt; upcase = methodcaller('upper')\n&gt;&gt;&gt; print(upcase(s))\n&gt;&gt;&gt; hyphenate = methodcaller('replace', ' ', '-')\n&gt;&gt;&gt; print(hyphenate(s))\nTHE TIME HAS COME\nThe-time-has-come\n</code></pre>"},{"location":"builtin_modules_examples/operator_module/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Operator \u2014 Standard operators as functions</li> </ul>"},{"location":"data_model/","title":"Data Model","text":""},{"location":"data_structures/dict/","title":"Dictionaries","text":"<p>A dict is a built-in data structure in Python.</p>"},{"location":"data_structures/dict/#characteristics","title":"Characteristics","text":"<ol> <li>Mutable Sequence</li> <li>Implemented using a hash table, highly optimized</li> <li> <code>Key</code> must be hashable objects They must implement proper <code>__hash__</code> and <code>__eq__</code> methods; </li> <li> <code>Item access by key is very fast</code> <p>Python can locate a key directly by computing the hash code of the key;</p> </li> <li> <p><code>Key ordering is preserved</code> as a side effect of a more compact memory layout;</p> </li> <li> Dicts inevitably have a significant memory overhead They most compact internal data structure for a container would be an array of pointers to the items. Compared to that, a hash table <code>needs to store more data per entry, and Python needs to keep at least one-third of the hash table rows empty to remain efficient</code> </li> </ol>"},{"location":"data_structures/dict/#dict-comprehensions","title":"Dict Comprehensions","text":"<p>A dictcomp (dict comprehension) build a dict instance by taking key:value pairs from any iterable.</p> dict_compre.py<pre><code>&gt;&gt;&gt; dial_codes = [\n...     (880, 'Bangladesh'),\n...     (55,  'Brazil'),\n...     (86,  'China'),\n...     (91,  'India'),\n... ]\n&gt;&gt;&gt; dict_country = { country: code \n...    for code, country in dial_codes }\n&gt;&gt;&gt; print(dict_country)\n{'Bangladesh': 880, 'Brazil': 55, 'China': 86, 'India': 91}\n</code></pre>"},{"location":"data_structures/dict/#unpacking-mappings","title":"Unpacking Mappings","text":"<p>Similar to sequence unpacking, you can <code>extract elements from a dictionary by using the * operator</code>. When you use a <code>single *, only the key</code> is returned, but when you <code>use **, both the key and the value</code> are returned.</p> dict_unpack.py<pre><code>&gt;&gt;&gt; def dump(*args,**kwargs):\n...     print(f\"args: {args} =&gt; just X, since we just unpack the key\")\n...     print(f\"kwargs: {kwargs}\")\n&gt;&gt;&gt; dump(*{'x': 1}, y=2, **{'z': 3})\nargs: ('x',) =&gt; just X, since we just unpack the key\nkwargs: {'y': 2, 'z': 3}\n</code></pre>"},{"location":"data_structures/dict/#merging-mappings","title":"Merging Mappings","text":"<p>Python 3.9 and above.</p> <p>You can <code>merge mappings using | and |=</code>, which are also used as set union operators. The <code>| operator creates a new dictionary</code>, while the <code>|= operator updates an existing mapping in place</code>.</p> merge_maps.py<pre><code>&gt;&gt;&gt; d1 = {'a': 1, 'b': 3}\n&gt;&gt;&gt; d2 = {'a': 2, 'b': 4, 'c': 6}\n&gt;&gt;&gt; merged_dicts = d1 | d2\n&gt;&gt;&gt; print(f\"merged_dicts =&gt; {merged_dicts} ============ d1 = {d1} and d2 {d2}\")\n&gt;&gt;&gt; print(\"ATTENTION: Please note that, in cases where keys have the same values, the values from d2 (on the right side of the operation) have been retained.\")\n&gt;&gt;&gt; print(\"--------------------------\")\n&gt;&gt;&gt; d1 |= d2\n&gt;&gt;&gt; print(f\"d1 = {d1} and d2 {d2}. Now d1 was updated\")\nmerged_dicts =&gt; {'a': 2, 'b': 4, 'c': 6} ============ d1 = {'a': 1, 'b': 3} and d2 {'a': 2, 'b': 4, 'c': 6}\nATTENTION: Please note that, in cases where keys have the same values, the values from d2 (on the right side of the operation) have been retained.\n--------------------------\nd1 = {'a': 2, 'b': 4, 'c': 6} and d2 {'a': 2, 'b': 4, 'c': 6}. Now d1 was updated\n</code></pre>"},{"location":"data_structures/dict/#pattern-matching","title":"Pattern Matching","text":"<p>Available in Python 3.10 and above!</p> <p>In Python's pattern matching, the <code>subject</code> is the data following the <code>match</code> keyword, which Python aims to <code>match with patterns in each case clause</code>.  One key improvement of match over switch is <code>destructuring</code> - a more advanced form of unpacking the subject. A case clause has two parts: a <code>pattern</code> and an <code>optional guard with the if keyword</code>.</p> <p>For subject <code>mapping pattern</code> matching, the following is necessary:</p> <ol> <li>The subject  is a instance of any actual or virtual subclass of <code>collections.abc.Mapping</code>;</li> <li>The <code>key orders is irrelevant</code>, even for OrderedDict;</li> <li>Mapping patterns succeed on <code>partial match</code>.</li> <li>You can prefix one variable with <code>** to capture extra key-value pairs</code> - It must be the last in the pattern;</li> </ol> pattern_matching.py<pre><code>&gt;&gt;&gt; def get_creators(record: dict) -&gt; list:\n...     match record:\n...         case {'type': 'book', 'api': 2, 'authors': [*names]}:\n...             print(\"type == book, api == 2 and ''authors' key mapped to sequence'\")\n...             return names\n...         case {'type': 'book', 'api': 1, 'author': name}:\n...             print(\"type == book, api == 2 and 'authors' key mapped to any object\")\n...             return [name]\n...         case {'type': 'book'}:\n...             print(\"No creators on dict\")\n...             raise ValueError(f\"Invalid 'book' record: {record!r}\")\n...         case _:\n...             raise ValueError(f'Invalid record: {record!r}')\n... \n&gt;&gt;&gt; b1 = dict(api=1, author='Douglas Hofstadter',\n...         type='book', title='G\u00f6del, Escher, Bach')\n&gt;&gt;&gt; print(f\"get_creators of b1: {get_creators(b1)}\")\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; b2 = OrderedDict(api=2, type='book',\n...         title='Python in a Nutshell',\n...         authors='Martelli Ravenscroft Holden'.split())\n&gt;&gt;&gt; print(f\"get_creators of b2: {get_creators(b2)}\")\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; try:\n...     get_creators({'type': 'book', 'pages': 770})\n... except BaseException as err:\n...     print(f\"Error: {err}\")\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; try:\n...     get_creators('Spam, spam, spam')\n... except BaseException as err:\n...     print(f\"Error: {err}\")\ntype == book, api == 2 and 'authors' key mapped to any object\nget_creators of b1: ['Douglas Hofstadter']\ntype == book, api == 2 and ''authors' key mapped to sequence'\nget_creators of b2: ['Martelli', 'Ravenscroft', 'Holden']\nNo creators on dict\nError: Invalid 'book' record: {'type': 'book', 'pages': 770}\nError: Invalid record: 'Spam, spam, spam'\n</code></pre> pattern_matching_partial_match.py<pre><code>&gt;&gt;&gt; food = dict(category='ice cream', flavor='vanilla', cost=199)\n&gt;&gt;&gt; match food:\n...     case {'category': 'ice cream', **details}:\n...         print(f'Ice cream details: {details}')\nIce cream details: {'flavor': 'vanilla', 'cost': 199}\n</code></pre>"},{"location":"data_structures/dict/#getting-inserting-or-updating","title":"Getting, Inserting or Updating","text":""},{"location":"data_structures/dict/#getting","title":"Getting","text":"<p>Dict acess with d[k] raises an error when k is not existing key. d.get(k, default) is an alternative whenever a default value is more convenient that handling KeyError</p>"},{"location":"data_structures/dict/#handling-missing-keys","title":"Handling Missing Keys","text":""},{"location":"data_structures/dict/#variations-of-dict","title":"Variations of Dict","text":""},{"location":"data_structures/dict/#immutable-mappings","title":"Immutable Mappings","text":""},{"location":"data_structures/dict/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"data_structures/list/","title":"List","text":"<p>A list is a built-in data structure in Python and is classified as a type of sequence data structure.</p>"},{"location":"data_structures/list/#characteristics","title":"Characteristics","text":"<ol> <li>Mutable Sequence</li> <li>Container Sequence</li> <li>Use square brackets []</li> </ol>"},{"location":"data_structures/list/#list-comprehensions","title":"List Comprehensions","text":"<p>List comprehensions provide a concise method for <code>creating lists</code>. Generator expressions for other kinds of sequences. They are commonly used to generate new lists by <code>applying operations to elements of an existing sequence or iterable</code>, or to create a sublist of elements that fulfill specific conditions.Using list comprehensions can significantly <code>enhance the readability of your code</code>.</p> <p>A list comprehension consists of <code>brackets</code> containing an expression followed by a <code>for clause, then zero or more for or if clauses</code>. The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it.</p>"},{"location":"data_structures/list/#examples","title":"Examples","text":"listcomp.py<pre><code>&gt;&gt;&gt; print(\"comparison with map function\")\n&gt;&gt;&gt; squares = list(map(lambda x: x**2, range(10)))\n&gt;&gt;&gt; print(f\"squares =&gt; {squares}\")\n&gt;&gt;&gt; squares = [x**2 for x in range(10)]\n&gt;&gt;&gt; print(f\"squares =&gt; {squares}\")\n&gt;&gt;&gt; print(\"comparison with filter function\")\n&gt;&gt;&gt; symbols = '$\u00a2\u00a3\u00a5\u20ac\u00a4'\n&gt;&gt;&gt; beyond_ascii = list(filter(lambda c: c &gt; 127, map(ord, symbols)))\n&gt;&gt;&gt; print(f\"beyond_ascii =&gt; {beyond_ascii}\")\n&gt;&gt;&gt; beyond_ascii = [ord(s) for s in symbols if ord(s) &gt; 127]\n&gt;&gt;&gt; print(f\"beyond_ascii =&gt; {beyond_ascii}\")\n&gt;&gt;&gt; print(\"Multiple listcomp\")\n&gt;&gt;&gt; combs = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n&gt;&gt;&gt; print(combs)\n&gt;&gt;&gt; combs = []\n&gt;&gt;&gt; for x in [1,2,3]:\n...     for y in [3,1,4]:\n...         if x != y:\n...             combs.append((x, y))\n&gt;&gt;&gt; print(combs)\ncomparison with map function\nsquares =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nsquares =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\ncomparison with filter function\nbeyond_ascii =&gt; [162, 163, 165, 8364, 164]\nbeyond_ascii =&gt; [162, 163, 165, 8364, 164]\nMultiple listcomp\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n</code></pre>"},{"location":"data_structures/list/#listsort-x-sorted-build-in","title":"list.sort x sorted Build-In","text":"<ol> <li>The list.sort method sorts a list in place (<code>without making a copy</code>):<ol> <li>It returns None - This follows an <code>important Python API convention: functions or methods that change an object in place should return None to make it clear to the caller</code>.</li> <li>We cannot chain calls to these methods.</li> </ol> </li> <li>The sorted function <code>creates a new list and returns it</code>:<ol> <li>It accepts any iterable object as an argument.</li> <li>It always returns a newly created list.</li> </ol> </li> <li>Both methods take two optional keyword-only arguments:<ol> <li><code>reverse</code>: If True, the items are returned in descending order. The default is False.</li> <li><code>key</code>: A one-argument function to be applied to each item.</li> </ol> </li> </ol> gen_enx.py<pre><code>&gt;&gt;&gt; fruits = ['grape', 'raspberry', 'apple', 'banana']\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits)}, fruits: {fruits}\")\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits, reverse=True)}, fruits: {fruits}\")\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits, key=len)}, fruits: {fruits}\")\n&gt;&gt;&gt; print(f\"sorted: {sorted(fruits, key=len, reverse=True)}, fruits: {fruits}\")\n&gt;&gt;&gt; fruits.sort()\n&gt;&gt;&gt; print(f\"Now fruits changed: {fruits}\")\nsorted: ['apple', 'banana', 'grape', 'raspberry'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nsorted: ['raspberry', 'grape', 'banana', 'apple'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nsorted: ['grape', 'apple', 'banana', 'raspberry'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nsorted: ['raspberry', 'banana', 'grape', 'apple'], fruits: ['grape', 'raspberry', 'apple', 'banana']\nNow fruits changed: ['apple', 'banana', 'grape', 'raspberry']\n</code></pre>"},{"location":"data_structures/list/#when-a-list-is-not-the-answer","title":"When a List is not the answer","text":"<ol> <li>An <code>array</code> saves a lot of memory when you need to handle millions of floating-point;</li> <li>A <code>deque</code> (double-ended queue) is more efficient <code>FIFO</code> (First-In First-out) data structure;</li> <li><code>Sets</code> are optimized for <code>fast membership checking</code>.</li> </ol>"},{"location":"data_structures/list/#extras","title":"Extras","text":"<ol> <li>Methods for lists</li> <li>Using Lists as Stacks</li> <li>Using Lists as Queues</li> </ol>"},{"location":"data_structures/list/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Python - More on List</li> </ul>"},{"location":"data_structures/sequence/","title":"Built-In Sequences","text":"<p>Python provides various built-in sequence types implemented in C, offering a rich set of functionalities through their APIs. These sequences include lists, tuples, strings, and range objects, each with its own unique features and use cases.</p>"},{"location":"data_structures/sequence/#classificationstypes-of-sequences","title":"Classifications/Types of Sequences","text":""},{"location":"data_structures/sequence/#container-x-flat","title":"Container x Flat","text":"<p>Container sequences, such as lists, tuples, and collections.deque, <code>can hold items of different types</code>, including other nested containers. They <code>hold references to the objects they contain</code>, which may be of any type.</p> <p>On the other hand, flat sequences, like str, bytes, and array.array, <code>hold items of one simple type and store the value of their contents in their own memory space</code>, not as separate Python objects. Refer to the image below for more details.</p> <p></p> <p>Container x Flat. Image from Fluent Python, 2nd Edition</p>"},{"location":"data_structures/sequence/#mutable-x-immutable","title":"Mutable x Immutable","text":"<p>Mutable sequences include list, bytearray, array.array, and collections.deque. These sequences <code>can be modified after creation</code>, allowing you to add, remove, or modify elements.</p> <p>Immutable sequences include tuple, str, and bytes. Once created, these sequences <code>cannot be changed</code>, meaning their elements cannot be modified or added.</p> <p><code>Mutable sequences inherit all methods from immutable sequences</code> and also implement several additional methods. Refer to the image below for more details.</p> <p></p> <p>Mutable Inherit. Image from Fluent Python, 2nd Edition</p>"},{"location":"data_structures/sequence/#unpacking","title":"Unpacking","text":"<p>Sequence unpacking in Python allows you to <code>extract elements from a sequence without using indexes</code>. It avoids unnecessary and error-prone index-based extraction. This feature <code>works with any iterable object</code>, including iterators that don't support index notation (using []). Instead of accessing elements by index, you can assign them directly to variables using unpacking.</p>"},{"location":"data_structures/sequence/#parallel-assignment","title":"Parallel assignment","text":"<p>The most visible form of unpacking, assigning items from an iterable to tuple of variable.</p> unpacking_parallel_assignment.py<pre><code>&gt;&gt;&gt; point = (123, 456)\n&gt;&gt;&gt; x, y = point\n&gt;&gt;&gt; print(f\"X: {x}\")\n&gt;&gt;&gt; print(f\"Y: {y}\")\nX: 123\nY: 456\n</code></pre> swapping_var_values.py<pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 15\n&gt;&gt;&gt; b, a = a, b\n&gt;&gt;&gt; print(f\"A: {a}, B: {b}\")\nA: 15, B: 10\n</code></pre>"},{"location":"data_structures/sequence/#using","title":"Using *","text":"<p>Use the <code>*</code> prefix when calling a function to perform <code>unpacking of elements from a sequence</code>. It allows you to pass <code>multiple arguments from a sequence as individual arguments</code> to the function.</p> unpacking_multiple_sequence.py<pre><code>&gt;&gt;&gt; data = (20, 8)\n&gt;&gt;&gt; quotient, remainder = divmod(*data)\n&gt;&gt;&gt; print(quotient, remainder)\n2 4\n</code></pre> <p>Using <code>*</code> to grab excess items</p> excess_items_unpacking.py<pre><code>&gt;&gt;&gt; a, b, *rest = range(5)\n&gt;&gt;&gt; print(\"REST ITEMS\")\n&gt;&gt;&gt; print(f\"WITH 5 =&gt; A: {a}, B: {b}, REST: {rest}\")\n&gt;&gt;&gt; a, b, *rest = range(3)\n&gt;&gt;&gt; print(f\"WITH 3 =&gt; A: {a}, B: {b}, REST: {rest}\")\n&gt;&gt;&gt; a, b, *rest = range(2)\n&gt;&gt;&gt; print(f\"WITH 2 =&gt; A: {a}, B: {b}, REST: {rest}\")\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; a, *body, c, d = range(5)\n&gt;&gt;&gt; print(\"MIDDLE ITEMS\")\n&gt;&gt;&gt; print(f\"A: {a}, BODY: {body}, C: {c}, D: {d}\")\n&gt;&gt;&gt; *head, b, c, d = range(5)\n&gt;&gt;&gt; print(f\"HEAD: {head}, B: {b}, C: {c}, D: {d}\")\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; print(\"In Function Calls\")\n&gt;&gt;&gt; def fun(a, b, c, d, *rest):\n...     return a, b, c, d, rest\n&gt;&gt;&gt; print(fun(*[1, 2], 3, *range(4, 7)))\n&gt;&gt;&gt; print()\n&gt;&gt;&gt; print(\"When defining list, tuple or set\")\n&gt;&gt;&gt; print(*range(4), 4)\n&gt;&gt;&gt; print([*range(4), 4])\n&gt;&gt;&gt; print({*range(4), 4, *(5, 6, 7)})\nREST ITEMS\nWITH 5 =&gt; A: 0, B: 1, REST: [2, 3, 4]\nWITH 3 =&gt; A: 0, B: 1, REST: [2]\nWITH 2 =&gt; A: 0, B: 1, REST: []\nMIDDLE ITEMS\nA: 0, BODY: [1, 2], C: 3, D: 4\nHEAD: [0, 1], B: 2, C: 3, D: 4\nIn Function Calls\n(1, 2, 3, 4, (5, 6))\nWhen defining list, tuple or set\n0 1 2 3 4\n[0, 1, 2, 3, 4]\n{0, 1, 2, 3, 4, 5, 6, 7}\n</code></pre>"},{"location":"data_structures/sequence/#with-functions-return","title":"With function's return","text":"<p>You can use unpacking from function returns to allow functions to <code>return multiple values</code> conveniently. The caller can easily unpack the values into separate variables.</p> swapping_var_values.py<pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; # doesn't work with strings\n&gt;&gt;&gt; raw_return = os.path.split('/home/aws_nice_cluster/.ssh/id_rsa.pub') \n&gt;&gt;&gt; print(f\"raw_return: {raw_return}, type: {type(raw_return)}\")\n&gt;&gt;&gt; _, filename = raw_return\n&gt;&gt;&gt; print(filename)\nraw_return: ('/home/aws_nice_cluster/.ssh', 'id_rsa.pub'), type: &lt;class 'tuple'&gt;\nid_rsa.pub\n</code></pre>"},{"location":"data_structures/sequence/#nested-unpacking","title":"Nested Unpacking","text":"swapping_var_values.py<pre><code>&gt;&gt;&gt; metro_areas = [\n...    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),  \n...    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),\n...    ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n&gt;&gt;&gt; print(f'{\"\":15} | {\"latitude\":&gt;9} | {\"longitude\":&gt;9}')\n&gt;&gt;&gt; for name, _, _, (lat, lon) in metro_areas:  \n...     if lon &lt;= 0:  \n...         print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n                |  latitude | longitude\nMexico City     |   19.4333 |  -99.1333\nNew York-Newark |   40.8086 |  -74.0204\nS\u00e3o Paulo       |  -23.5478 |  -46.6358\n</code></pre>"},{"location":"data_structures/sequence/#pattern-matching","title":"Pattern Matching","text":"<p>Available in Python 3.10 and above!</p> <p>In Python's pattern matching, the <code>subject</code> is the data following the <code>match</code> keyword, which Python aims to <code>match with patterns in each case clause</code>.  One key improvement of match over switch is <code>destructuring</code> - a more advanced form of unpacking the subject. A case clause has two parts: a <code>pattern</code> and an <code>optional guard with the if keyword</code>.</p> <p>For subject <code>sequence pattern</code> matching, the following is necessary:</p> <ol> <li>The subject  is a sequence;</li> <li>The subject and the pattern have the same number of items and;</li> <li>Each corresponding item matches, including nested items.</li> </ol> sequence_matching_basic.py<pre><code>&gt;&gt;&gt; def demonstration(self, message_type: list[str]) -&gt; str:\n...     match message_type: # message_type is the SUBJECT\n...         case ['AAAA', 'BBB', 'CCC']:\n...             return 'ABC'\n...         case ['BBB', 'CCC']:\n...             return 'BC'\n...         case ['CCC']:\n...             return 'C'\n...         case _:\n...             return ''\n</code></pre> sequence_matching_complex.py<pre><code>&gt;&gt;&gt; metro_areas = [\n...     ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),\n...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n...     ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),\n...     ('S\u00e3o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n... ]\n&gt;&gt;&gt; print(f'{\"\":15} | {\"latitude\":&gt;9} | {\"longitude\":&gt;9}')\n&gt;&gt;&gt; for record in metro_areas:\n&gt;&gt;&gt;     match record:  \n&gt;&gt;&gt;         case [name, _, _, (lat, lon)] if lon &lt;= 0: # using IF on case clause\n&gt;&gt;&gt;             print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n                |  latitude | longitude\nMexico City     |   19.4333 |  -99.1333\nNew York-Newark |   40.8086 |  -74.0204\nS\u00e3o Paulo       |  -23.5478 |  -46.6358\n</code></pre>"},{"location":"data_structures/sequence/#special-treatment","title":"Special Treatment","text":"<ol> <li>In sequence patterns, <code>both square brackets and parentheses have the same significance</code>;</li> <li> <p>Cannot match sequences of type <code>str</code>, <code>bytes</code> and <code>bytearray</code>:</p> <ol> <li>A match subject of those types is <code>treated as an atomic value</code>;</li> <li>To treat as a sequence, <code>convert it in the match clause</code>;</li> </ol> <p>convert_str_match.py<pre><code>&gt;&gt;&gt; def phone_location(phone: str):\n&gt;&gt;&gt;     match tuple(phone):\n...         case ['1', *rest]:  # North America and Caribbean\n...             return 1\n...         case ['2', *rest]:  # Africa and some territories\n...             return 2\n...         case ['3' | '4', *rest]:  # Europe\n...             return 3\n</code></pre> </p> </li> <li> <p>The <code>_</code> symbol: it matches any single item in that position, but it is never bound to the value to the match item:</p> <ol> <li>Also, the only variable that <code>can appear more than once</code></li> </ol> using_.py<pre><code># ['Shanghai', 'CN', 24.9, (31.1, 121.3)]\ncase [name, _, _, (lat, lon) as coord]: \n# name = Shanghai\n# lat = 31.1\n# lon = 121.3\n# coord = (31.1, 121.3)\n</code></pre> </li> </ol>"},{"location":"data_structures/sequence/#examples","title":"Examples","text":"<p>First case:</p> <ol> <li>The first item must be an instance of <code>str</code>;</li> <li>Item 3 must be a <code>pair of floats</code>.</li> </ol> match_by_type.py<pre><code>case [str(name), _, _, (float(lat), float(lon))]:\n</code></pre> <p>Second case:</p> <ol> <li>Match any subject sequence <code>starting with a str</code></li> <li>Ending with a <code>nested sequence of two floats</code></li> </ol> match_by_type.py<pre><code>case [str(name), *_, (float(lat), float(lon))]:\n</code></pre> <ul> <li>The <code>*_</code> matches any number of items, <code>without binding them to a variable</code>;</li> <li>Using <code>*extra</code> instead of *_ would bind the items to <code>extra as a list</code> with 0 or more items.</li> </ul>"},{"location":"data_structures/sequence/#generator-expressions","title":"Generator Expressions","text":"<p>Generator expressions (gen-expr) are employed to <code>construct sequences</code>.  They <code>save memory by yielding items one by one</code> via the iterator protocol, unlike listcomps, which builds an entire list before feeding another constructor. Generator expressions share the same syntax as listcomps but <code>use parentheses</code> instead of brackets.</p> <p>Variables assigned using the \"Walrus operator\" <code>:= remain accessible after the comprehensions or expressions from which they originate return</code>, unlike local variables within functions. The scope of the target of := is the enclosing function, unless a global or nonlocal declaration is made for that target.</p> gen_enx.py<pre><code>&gt;&gt;&gt; symbols = '$\u00a2\u00a3\u00a5\u20ac\u00a4'\n&gt;&gt;&gt; order_symbols = tuple(ord(symbol) for symbol in symbols)\n&gt;&gt;&gt; print(order_symbols)\n&gt;&gt;&gt; string_int = \"12345\"\n&gt;&gt;&gt; raw_gen = (value for value in string_int) \n&gt;&gt;&gt; print(type(raw_gen))\n&gt;&gt;&gt; print(set(raw_gen))\n&gt;&gt;&gt; codes = [last := ord(c) for c in string_int]\n&gt;&gt;&gt; print(last)\n(36, 162, 163, 165, 8364, 164)\n&lt;class 'generator'&gt;\n{'1', '4', '5', '2', '3'}\n53\n</code></pre>"},{"location":"data_structures/sequence/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"data_structures/set/","title":"Set","text":"<p>A set is a built-in data structure in Python and is classified as a type of sequence data structure.</p>"},{"location":"data_structures/set/#characteristics","title":"Characteristics","text":"<ol> <li>Mutable Sequence</li> <li>Container Sequence</li> <li><code>Eliminate all duplicates</code></li> <li>Unordered</li> <li>Support mathematical operations like union, intersection, difference, and symmetric difference</li> <li>Use braces  {}</li> <li>Implemented using a hash table, a property also applicable to FrozenSets.</li> <li>Membership testing is very efficient</li> </ol>"},{"location":"data_structures/set/#creating-a-set","title":"Creating a set","text":"<p>Utilizing literal set syntax such as <code>{1, 2, 3} is not only quicker but also enhances readability</code> compared to employing the constructor like set([1, 2, 3]). The constructor approach is slower due to the need for Python to search for the set's constructor, compile a list, and subsequently pass it to the constructor.</p> creating_set.py<pre><code>&gt;&gt;&gt; s = {1}\n&gt;&gt;&gt; print(f\"using {{}} to create: {type(s)}\")\n&gt;&gt;&gt; print(s)\n&gt;&gt;&gt; print(s.pop())\n&gt;&gt;&gt; print(s)\n&gt;&gt;&gt; g = set([1, 2, 3])\n&gt;&gt;&gt; print(f\"using {{}} to create: {type(g)}\")\n&gt;&gt;&gt; print(g)\n&gt;&gt;&gt; print(g.pop())\n&gt;&gt;&gt; print(g)\nusing {} to create: &lt;class 'set'&gt;\n{1}\n1\nset()\nusing {} to create: &lt;class 'set'&gt;\n{1, 2, 3}\n1\n{2, 3}\n</code></pre>"},{"location":"data_structures/set/#set-comprehensions-setcomps","title":"Set Comprehensions (setcomps)","text":"setcomps.py<pre><code>&gt;&gt;&gt; from unicodedata import name\n&gt;&gt;&gt; setcomp = {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i),'')}\n&gt;&gt;&gt; print(type(setcomp))\n&gt;&gt;&gt; print(setcomp)\n&lt;class 'set'&gt;\n{'=', '\u00ae', '\u00b0', '\u00ac', '\u00a2', '\u00f7', '%', '&gt;', '\u00a5', '\u00a9', '\u00d7', '#', '\u00a7', '\u00b6', '$', '+', '\u00a3', '\u00a4', '\u00b1', '\u00b5', '&lt;'}\n</code></pre>"},{"location":"data_structures/set/#elements-must-be-hashable","title":"Elements Must Be Hashable","text":"<p><code>Elements within a set must be hashable objects</code>, complete with appropriate implementations of <code>__hash__</code> and <code>__eq__</code> methods. It's important to note that the <code>set type itself isn't hashable</code>, preventing the construction of sets with nested set instances. However, FrozenSet is hashable, allowing for the inclusion of frozenset elements within a set.</p>"},{"location":"data_structures/set/#frozenset","title":"FrozenSet","text":"<p><code>A FrozenSet is an immutable variation of a set</code>. Unlike sets, there is no distinct syntax to denote frozenset literals. Instead, they are generated by invoking the constructor.</p> frozen_set.py<pre><code>&gt;&gt;&gt; my_frozen = frozenset(range(10))\n&gt;&gt;&gt; print(type(my_frozen))\n&gt;&gt;&gt; print(my_frozen)\n&lt;class 'frozenset'&gt;\nfrozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})\n</code></pre>"},{"location":"data_structures/set/#set-operations","title":"Set Operations","text":""},{"location":"data_structures/set/#infix-operators","title":"Infix Operators","text":"frozen_set.py<pre><code>&gt;&gt;&gt; a = {1, 2, 3 }\n&gt;&gt;&gt; b = {3, 4, 5 }\n&gt;&gt;&gt; print(f\"UNION of A and B: {a | b}\")\n&gt;&gt;&gt; print(f\"INTERSECTION of A and B: {a &amp; b}\")\n&gt;&gt;&gt; print(f\"DIFFERENCE of A and B: {a - b}\")\n&gt;&gt;&gt; print(f\"SYMMETRIC DIFFERENCE of A and B: {a ^ b}\")\nUNION of A and B: {1, 2, 3, 4, 5}\nINTERSECTION of A and B: {3}\nDIFFERENCE of A and B: {1, 2}\nSYMMETRIC DIFFERENCE of A and B: {1, 2, 4, 5}\n</code></pre>"},{"location":"data_structures/set/#method-list","title":"Method List","text":"<p>Python Set documentation for a comprehensive list of set and frozen set methods and operations.</p>"},{"location":"data_structures/set/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Python - Sets</li> </ul>"},{"location":"data_structures/tuple/","title":"Tuple","text":"<p>A set is a built-in data structure in Python and is classified as a type of sequence data structure.</p>"},{"location":"data_structures/tuple/#characteristics","title":"Characteristics","text":"<ol> <li>Immutable Sequence</li> <li>Container Sequence</li> <li>Can be used as record</li> <li>Just the tuple object is immutable, the tuple's element can change.</li> <li>Use parentheses ()</li> <li>Usually contain a heterogeneous sequence</li> </ol>"},{"location":"data_structures/tuple/#the-tuples-references-to-mutable-objects","title":"The Tuples references to Mutable Objects","text":"<p>Basic concepts:</p> <ol> <li>Object References</li> </ol> <p>The concept of <code>immutability in tuples specifically pertains to the tuple's references</code>. It's crucial to note that while tuples themselves are immutable, this <code>immutability does not extend to the mutable objects they may reference</code>. Care should be taken when dealing with tuples containing mutable items to avoid potential sources of bugs.</p> tuple_refs.py<pre><code>&gt;&gt;&gt; a = (10, 'alpha', [1, 2])\n&gt;&gt;&gt; b = (10, 'alpha', [1, 2])\n&gt;&gt;&gt; print(f\"a == b? {a == b}, A type = {type(a)} and B type = {type(b)}\")\n&gt;&gt;&gt; b[-1].append(99)\n&gt;&gt;&gt; print(f\"a == b? {a == b}\")\n&gt;&gt;&gt; print(f\"A now: {a} vs B now: {b}\")\na == b? True, A type = &lt;class 'tuple'&gt; and B type = &lt;class 'tuple'&gt;\na == b? False\nA now: (10, 'alpha', [1, 2]) vs B now: (10, 'alpha', [1, 2, 99])\n</code></pre>"},{"location":"data_structures/tuple/#tuples-as-records","title":"Tuples as Records","text":"<p>If you are <code>familiar with the structure</code> of tuple objects, you can utilize tuples as record data, with each <code>item in the tuple representing data for a specific field</code>. The sequence of items holds significance, and the count of fields remains constant.</p> tuple_as_records.py<pre><code>&gt;&gt;&gt; countries_nationality = [('Chile', 'Chilean'), ('Brazil', 'Brazilian'), ('Argentina', 'Argentine'), ('Uruguay', 'Uruguayan')]\n&gt;&gt;&gt; for country, nationality in countries_nationality:\n...     print(f\"Country field: {country}, Nationality: {nationality}\")\nCountry field: Chile, Nationality: Chilean\nCountry field: Brazil, Nationality: Brazilian\nCountry field: Argentina, Nationality: Argentine\nCountry field: Uruguay, Nationality: Uruguayan\n</code></pre>"},{"location":"data_structures/tuple/#tuples-vs-lists","title":"Tuples vs Lists","text":"<p>Using Tuples instead of Lists can bring both <code>performance benefits and clarity</code> to your code:</p> <ol> <li>Clarity: When you encounter a tuple in the code, you can be certain that its <code>length will remain constant</code>.</li> <li>Performance: <code>Tuples consume less memory</code> compared to a list of equivalent length, enabling Python to implement optimizations.</li> </ol> <p>A deeper discussion can be found here in this StackOverflow answer by Python core developer Raymond Hettinger</p> <p>A deeper discussion can be found here in this StackOverflow answer provided by Raymond Hettinger, a Python core developer.</p>"},{"location":"data_structures/tuple/#named-tuples","title":"Named Tuples","text":"<p>Named tuples in Python offer a way to <code>create tuples that enable you to access values using descriptive field names and the dot notation</code>, instead of relying on ambiguous integer indices.</p>"},{"location":"data_structures/tuple/#collectionsnamedtuple","title":"collections.namedtuple","text":"<p>Python's <code>namedtuple()</code> resides within the <code>collections</code> module as a factory function. It empowers you to generate <code>subclasses of tuples</code>, complete with named fields. This offers supplementary methods and attributes like <code>._make()</code>, <code>_asdict()</code>, and .<code>_fields</code>, among others. Notably, named tuples <code>maintain backward compatibility</code> with conventional tuples while <code>exhibiting comparable memory usage</code>.</p> named_tuple_collections.py<pre><code>&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Point = namedtuple(\"Point\", \"x y\")\n&gt;&gt;&gt; print(f\"Is subclass of tuple? {issubclass(Point, tuple)}\")\n&gt;&gt;&gt; point = Point(2, 4)\n&gt;&gt;&gt; print(point, point.x, point.y)\n&gt;&gt;&gt; print(point, point[0], point[1])\nIs subclass of tuple? True\nPoint(x=2, y=4) 2 4\nPoint(x=2, y=4) 2 4\n</code></pre> <p>For further customization, including required and optional arguments, along with other details, see the the Real Python article.</p>"},{"location":"data_structures/tuple/#typingnamedtuple","title":"typing.NamedTuple","text":"<p>Within the <code>typing</code> module, there exists <code>NamedTuple</code>, a typed variant of namedtuple. This allows to craft namedtuple classes with <code>type annotations</code>. Notably, <code>both namedtuple and NamedTuple instances exhibit identical memory consumption characteristics</code>.</p> named_tuple_typing.py<pre><code>&gt;&gt;&gt; from typing import NamedTuple\n&gt;&gt;&gt; class Person(NamedTuple):\n...     name: str\n...     age: int\n...     country: str = \"Canada\"\n</code></pre>"},{"location":"data_structures/tuple/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Python - Tuples and Sequences</li> <li>Real Python - Write Pythonic and Clean Code With namedtuple</li> </ul>"},{"location":"decorators_closures/closures/","title":"Closures","text":"<p>To comprehend closures, it's essential to have a solid understanding of variable scopes.</p> <p>It's not the same thing that anonymous functions. <code>Closure focus on nested functions</code>, that one function can access nonglobal variable that are defined outside of its body, does not matter whether the function is anonymous or not.</p> Example <p><pre><code>&gt;&gt;&gt; def make_averager():\n...     series = []\n...     test_nice = \"nice\"\n...     def averager(new_value):\n...         series.append(new_value) # accessing series\n...         return sum(series) / len(series)\n...     return averager\n&gt;&gt;&gt; avg = make_averager()\n&gt;&gt;&gt; print(avg(10))\n&gt;&gt;&gt; print(avg(11))\n&gt;&gt;&gt; print(avg(15))\n&gt;&gt;&gt; print(avg.__code__.co_varnames)\n&gt;&gt;&gt; print(f\"freevars: {avg.__code__.co_freevars}\")\n&gt;&gt;&gt; print(f\"__closure__: {avg.__closure__}\")\n&gt;&gt;&gt; print(avg.__closure__[0].cell_contents)\n10.0\n10.5\n12.0\n('new_value',)\nfreevars: ('series',)\n__closure__: (&lt;cell at 0x7f3746a491e0: list object at 0x7f3746cf5f40&gt;,)\n[10, 11, 15]\n</code></pre> </p> <p>In this is example, <code>make_averager function return a callable object</code>. The <code>averager</code> function updates the series list and return the current mean.</p>"},{"location":"decorators_closures/closures/#how-it-works","title":"How it Works","text":"<p>Read nonlocal scope to understand free variables.</p> <p>Using the example as base, the <code>averager function is a closure</code>. The <code>averager</code> function <code>can access the series variable</code> defined on make_averager because <code>series is a free variable</code>. This is a technical term meaning a variable that is not bound in the local scope. Only variables referenced on the closure are mappend, like is possible to see in the test_nice variable.</p> <p>Closures functions is only available inside the outer function, so its commom to return the closure function to be consume externally.</p>"},{"location":"decorators_closures/closures/#assigning-variables-and-nonlocal-keyword-used","title":"Assigning Variables and nonlocal Keyword used","text":"<p>In the example, it <code>worked because series is a list</code>, which can be changed using 'series.append()'. But <code>if series were an integer</code>, which can't be altered, and the code tried something like <code>series += new_value</code>, <code>it would cause an error</code>: \"local variable 'series' referenced before assignment\". This occurs because <code>when you attempt to rebind series</code> (as in 'series += new_value'), it <code>implicitly creates a local variable called series</code>, and at this point, series is no longer a free variable.</p> <p>To resolve this issue, you need to use the <code>nonlocal</code> keyword, which allows you to declare a free variable. When a <code>new value is assigned to a nonlocal variable</code>, the binding stored in the closure is updated.</p> example_with_nonlocal.py<pre><code>&gt;&gt;&gt; def make_averager():\n...    count = 0\n...    total = 0\n&gt;&gt;&gt;    def averager(new_value):\n...        nonlocal count, total\n...        count += 1\n...        total += new_value\n...        return total / count\n...    return averager\n&gt;&gt;&gt; avg = make_averager()\n&gt;&gt;&gt; print(avg(10))\n&gt;&gt;&gt; print(avg(11))\n&gt;&gt;&gt; print(avg(15))\n10.0\n10.5\n12.0\n</code></pre>"},{"location":"decorators_closures/closures/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"decorators_closures/decorators/","title":"Decorators","text":"<p>A decorator is a <code>function that takes another function (the decorated function) as its input</code>. It can perform some actions with the decorated function and either return it or substitute it with another function or callable object. To become proficient in using decorators, it's important to grasp the concept of closures.</p> <p>In essence, <code>decorators are syntactic sugar</code>, as you can always directly call a decorator just like any regular callable as demonstrated in <code>decorator_example.py</code>. In summary, decorators are:</p> <ol> <li>A decorator is a function or another callable;</li> <li>A decorator can replace the decorated function with a different one or perform pre- or post-processing;</li> <li><code>Decorators are executed immediately when a module is loaded</code>;</li> </ol> Decorator Example <p>decorator_example.py<pre><code>&gt;&gt;&gt; def decorate(func):\n...     def inner():\n...         print('running inner()')\n...         func()\n...     return inner\n&gt;&gt;&gt; @decorate\n&gt;&gt;&gt; def target():\n...    print('running target()')\n&gt;&gt;&gt; target()\n&gt;&gt;&gt; print(\"EQUALS TO:\")\n&gt;&gt;&gt; def target():\n...    print('running target()')\n&gt;&gt;&gt; target = decorate(target)\n&gt;&gt;&gt; target()\nrunning inner()\nrunning target()\nEQUALS TO:\nrunning inner()\nrunning target()\n</code></pre> </p>"},{"location":"decorators_closures/decorators/#decorators-execution-flow","title":"Decorators Execution Flow","text":"<p><code>Decorators are executed as soon as the module is imported</code>, but the <code>decorated functions only run when they are explicitly called</code>. This emphasizes the <code>distinction between \"import time\" and \"runtime\"</code>.</p> Decorator Execution Flow src/decorators/decorator_execution.py<pre><code>decorator_log = []\ndef decorator_func(func):\ndecorator_log.append(func)\nprint(f\"Executing decorator!! COUNT: {decorator_log}\")\nreturn func\n@decorator_func\ndef f1():\nprint(\"F1 execution!!\")\n@decorator_func\ndef f2():\nprint(\"F2 execution!!\")\ndef f3():\nprint(\"F3 execution!!\")\ndef main():\nprint(\"Starting MAIN!\")\nprint(f\"decorator_log on MAIN -&gt; {decorator_log}\")\nf1()\nf2()\nf3()\nif __name__ == \"__main__\":\nmain()\n</code></pre> output<pre><code>Executing decorator!! COUNT: [&lt;function f1 at 0x7f8c665e8d60&gt;]\nExecuting decorator!! COUNT: [&lt;function f1 at 0x7f8c665e8d60&gt;, &lt;function f2 at 0x7f8c665e8680&gt;]\nStarting MAIN!\ndecorator_log on MAIN -&gt; [&lt;function f1 at 0x7f8c665e8d60&gt;, &lt;function f2 at 0x7f8c665e8680&gt;]\nF1 execution!!\nF2 execution!!\nF3 execution!!\n</code></pre>"},{"location":"decorators_closures/decorators/#stacked-decorators","title":"Stacked Decorators","text":"<p>When a function is decorated with more than one decorator, the <code>innermost decorator is applied first</code>. Then, the function it returns is passed forward to the next decorator in the stack.</p> Stacked Decorators stacked_decorators.py<pre><code>&gt;&gt;&gt; @decorator1\n&gt;&gt;&gt; @decorator2\n&gt;&gt;&gt; def fun(n):\n...     ...\n&gt;&gt;&gt; print(\"Is the same as this: \")\n&gt;&gt;&gt; fun = decorator2(decorator1(my_fn))\n</code></pre>"},{"location":"decorators_closures/decorators/#parameterized-decorators","title":"Parameterized Decorators","text":"<p>When using decorators in Python, the <code>decorated function is passed as the first argument to the decorator function</code>. If you want a decorator to accept additional arguments, you need to create a <code>decorator factory</code>. <code>This factory function takes those extra arguments</code> and returns a decorator, which can then be applied to the function you want to decorate.</p> Simple Parameterized Decorator <p>parameter_decorator_example.py<pre><code>&gt;&gt;&gt; def nice_logger(extra_info=True):\n...     def decorate(func):\n...         print(\"passing nice_logger\")\n...         if extra_info:\n...             print(f\"printing extra_info: {extra_info}. func {func}\")\n...         return func\n...     return decorate\n&gt;&gt;&gt; @nice_logger(extra_info=False)\n&gt;&gt;&gt; def f1():\n...     print(\"f1()\")\n&gt;&gt;&gt; @nice_logger()\n&gt;&gt;&gt; def f2():\n...     print(\"f2()\")\n&gt;&gt;&gt; @nice_logger()\n&gt;&gt;&gt; def f3():\n...     print(\"f3()\")\n&gt;&gt;&gt; f1()\n&gt;&gt;&gt; f2()\n&gt;&gt;&gt; f3()\npassing nice_logger\npassing nice_logger\nprinting extra_info: True. func &lt;function f2 at 0x7f3746bdee80&gt;\npassing nice_logger\nprinting extra_info: True. func &lt;function f3 at 0x7f3746bdef20&gt;\nf1()\nf2()\nf3()\n</code></pre> </p> <ol> <li>nice_logger is not a decorator but a <code>decorator factory</code>;</li> <li><code>decorate inner function is the actual decorator</code>, taking a function as an argument;</li> <li>Even when no parameters are passed, nice_logger must still be called as a function nice_logger();</li> <li>The main point is that <code>nice_logger() returns decorate, which is then applied to the decorated function</code>.</li> <li>using @ syntax, is equivalent to <code>nice_logger()(f1) or nice_logger(extra_info=False)(f1)</code></li> </ol> Parameterized Decorator passing arguments <p>parameter_decorator_example.py<pre><code>&gt;&gt;&gt; def nice_logger(extra_info=\"\"):\n...     def decorate(func):\n...         def logger(*_args):\n...             result = func(*_args)\n...             if extra_info:\n...                 print(f\"{extra_info}: {result}\")\n...             return result\n...         return logger\n...     return decorate\n&gt;&gt;&gt; @nice_logger(extra_info=\"F1: The final result is \")\n&gt;&gt;&gt; def f1(num1):\n...     return 10 + num1\n&gt;&gt;&gt; @nice_logger()\n&gt;&gt;&gt; def f2(num1):\n...     return 20 + num1\n&gt;&gt;&gt; @nice_logger()\n&gt;&gt;&gt; def f3(num1):\n...     return 30 + num1\n&gt;&gt;&gt; f1(10)\n&gt;&gt;&gt; f2(10)\n&gt;&gt;&gt; f3(10)\nF1: The final result is : 20\n</code></pre> </p> <ol> <li>The key distinction here is that the decorated function accepts parameters.</li> <li>The <code>logger function</code> returns the result of the decorated function.</li> <li>The decorate function returns the logger function.</li> </ol>"},{"location":"decorators_closures/decorators/#class-based-decorator","title":"Class-Based Decorator","text":"<p>Instead of using a function to decorate a function, <code>you can use a class object that implements the __call__ method</code>. This allows you to create decorators using classes, providing more flexibility and control over the decoration process.</p> Parameterized Decorator passing arguments src/decorators/class_decorator.py<pre><code>from typing import Any\nclass nice_logger:\ndef __init__(self, string_log = \"\") -&gt; None:\nself.string_log = string_log\ndef __call__(self, func) -&gt; Any:\ndef logger(*_args):\nresult = func(*_args)\nif self.string_log:\nprint(f\"{self.string_log}: {result}\")\nreturn result\nreturn logger\n@nice_logger(string_log=\"F1: The final result is \")\ndef f1(num1):\nreturn 10 + num1\nf1(10)\n</code></pre>"},{"location":"decorators_closures/decorators/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>PythonDecoratorLibrary</li> </ul>"},{"location":"functions/basic/","title":"Basic of Functions","text":""},{"location":"functions/basic/#definitions-and-arguments","title":"Definitions and Arguments","text":"<p>The <code>def</code> keyword introduces a function definition, followed by the function name and a list of formal parameters enclosed in parentheses. The function body starts on the next line and must be indented.</p> <p>When a function is called, the actual parameters (arguments) are introduced into the local symbol table of the called function. This is done using \"call by value,\" where the value passed is always an object reference, not the value of the object itself. If a function calls another function or itself recursively, a new local symbol table is created for that call.</p> fun_definition.py<pre><code>&gt;&gt;&gt; def add_number(num1: int, num2: int) -&gt; int:\n...     # typing arguments and return are optional\n...     return num1 + num2\n</code></pre> <p>Functions that belong to a class require the first argument to be <code>self</code>, which is used to pass the object reference to the function. This enables access to the class's attributes and methods within the function's body.</p> fun_class.py<pre><code>&gt;&gt;&gt; class Nice:\n...     ...\n&gt;&gt;&gt;     def nice_func(self):\n...         print(\"Nice object func starting with self\")\n</code></pre>"},{"location":"functions/basic/#return","title":"Return","text":"<p>Functions in Python can indeed return multiple values. When a function is called, it can produce multiple results. This capability allows functions to provide comprehensive information or results that can be used further in the code.</p> mult_return.py<pre><code>&gt;&gt;&gt; def add_sub_numbers(num1: int, num2: int) -&gt; tuple[int, int]:\n...     return num1 + num2, num1 - num2\n&gt;&gt;&gt; print(add_sub_numbers(2, 2))\n(4, 0)\n</code></pre> <p>Moreover, even functions that do not explicitly contain a return statement still return a value, albeit a default and unexciting one called <code>None</code>. When the return statement is missing, the interpreter automatically returns <code>None</code> as the function's output.</p> fun_none.py<pre><code>&gt;&gt;&gt; def add_number_print(num1: int, num2: int):\n...     print(num1 + num2)\n&gt;&gt;&gt; print(add_number_print(2, 2))\n4\nNone\n</code></pre>"},{"location":"functions/basic/#the-nine-types-of-callable-objects","title":"The Nine Types of Callable Objects","text":"<p>To determine whether an object is callable, use the\u00a0<code>callable()</code>\u00a0built-in function.</p>"},{"location":"functions/basic/#user-defined-functions","title":"User-Defined Functions","text":"<p>Created with <code>def</code> statements or <code>lambda</code> expressions;</p>"},{"location":"functions/basic/#built-in-functions","title":"Built-in Functions","text":"<p>A\u00a0function implemented in C (for CPython), like\u00a0<code>len</code>\u00a0or\u00a0<code>time.strftime</code>.</p>"},{"location":"functions/basic/#built-in-methods","title":"Built-in Methods","text":"<p>Methods\u00a0implemented in C, like\u00a0<code>dict.get</code>.</p>"},{"location":"functions/basic/#methods","title":"Methods","text":"<p>Functions defined in the body of a class.</p>"},{"location":"functions/basic/#classes","title":"Classes","text":"<p>When\u00a0invoked, a class runs its\u00a0<code>__new__</code>\u00a0method to create an instance, then\u00a0<code>__init__</code>\u00a0to initialize it, and finally the instance is returned to the caller;</p>"},{"location":"functions/basic/#class-instances","title":"Class instances","text":"<p>If a class defines a\u00a0<code>__call__</code>\u00a0method, then its instances may be invoked as functions;</p>"},{"location":"functions/basic/#generator-functions","title":"Generator Functions","text":"<p>Functions or methods that use the\u00a0<code>yield</code>\u00a0keyword in their body. When called, they return a generator object.</p>"},{"location":"functions/basic/#native-coroutine-functions","title":"Native Coroutine Functions","text":"<p>Functions\u00a0or methods defined with\u00a0<code>async def</code>. When called, they return a coroutine object.</p>"},{"location":"functions/basic/#asynchronous-generator-functions","title":"Asynchronous Generator Functions","text":"<p>Functions\u00a0or methods defined with\u00a0<code>async def</code>\u00a0that have\u00a0<code>yield</code>\u00a0in their body. When called, they return an asynchronous generator for use with\u00a0<code>async for</code></p>"},{"location":"functions/basic/#references","title":"References","text":"<ul> <li>Python - 4.7. Defining Functions</li> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"functions/hof_lamda_functions/","title":"High-Order and Lambda Function","text":""},{"location":"functions/hof_lamda_functions/#high-order-functions","title":"High-Order Functions","text":"<p>A function is classified as a Higher Order Function (HOF) when it <code>takes other functions as parameters or returns a function as its output</code>. In other words, HOFs are functions that interact with other functions. Common examples of HOFs include map, filter, and reduce. These functions accept any one-argument function as a key.</p> <p>Key properties of higher-order functions:</p> <ol> <li>Functions are instances of the Object type.</li> <li>Functions can be stored in variables.</li> <li>Functions can be passed as parameters to other functions.</li> <li>Functions can be returned from a function.</li> <li>Functions can be stored in data structures like hash tables and lists.</li> </ol> lambda.py<pre><code>&gt;&gt;&gt; fruits = ['banana', 'apple', 'fig', 'strawberry', 'cherry', 'raspberry']\n&gt;&gt;&gt; def reverse(word):\n...     return word[::-1]\n&gt;&gt;&gt; print(reverse('testing'))\n&gt;&gt;&gt; print(list(map(reverse, fruits)))\ngnitset\n['ananab', 'elppa', 'gif', 'yrrebwarts', 'yrrehc', 'yrrebpsar']\n</code></pre>"},{"location":"functions/hof_lamda_functions/#anonymouslambda-functions","title":"Anonymous/Lambda Functions","text":"<p>Lambda functions can be used wherever function objects are required. They can only contain <code>pure expressions and cannot include other Python statements</code> like while, try, or assignment statements. Despite these limitations, lambda functions are semantically <code>equivalent to normal function definitions and act as syntactic sugar for them.</code> Lambda functions are commonly used when a simple, short function is required, and there's no need to define a full-fledged function using the def statement. Like nested function definitions, lambda functions can reference variables from the containing scope:</p> lambda.py<pre><code>&gt;&gt;&gt; def make_incrementor(n):\n...    return lambda x: x + n\n&gt;&gt;&gt; f = make_incrementor(42)\n&gt;&gt;&gt; print(f(0))\n&gt;&gt;&gt; print(f(1))\n42\n43\n</code></pre> lambda2.py<pre><code>&gt;&gt;&gt; fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']\n&gt;&gt;&gt; print(sorted(fruits, key=lambda word: word[::-1]))\n['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry']\n</code></pre>"},{"location":"functions/hof_lamda_functions/#references","title":"References","text":"<ul> <li>Geeks for Geeks - Higher Order Functions in Python</li> </ul>"},{"location":"functions/parameters/","title":"Parameters","text":"<p>In Python, parameter passing follows the concept of <code>call by sharing</code>. This means that each formal parameter of the function receives a copy of each reference in the arguments. As a result, the parameters inside the function become aliases of the actual arguments. While the <code>function can modify any mutable object passed as a parameter</code>, it cannot change the identity of those objects.</p> <p>Understanding this mechanism is crucial for working with functions in Python, as it ensures that modifications to parameters within a function do not affect the original objects in the calling code.</p> parameters.py<pre><code>&gt;&gt;&gt; def nice_function(a, b):\n...     a += b\n...     return a\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 2\n&gt;&gt;&gt; print(f\"nice_function(x, y): {nice_function(x, y)}\")\n&gt;&gt;&gt; print(f\"X and Y didn't change: {x , y}\")\n&gt;&gt;&gt; print(\"Reason: int is immutable\")\n&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; print(f\"nice_function(a, b): {nice_function(a, b)}\")\n&gt;&gt;&gt; print(f\"A and B change: {a , b}\")\n&gt;&gt;&gt; print(\"Reason: list is mutable\")\nnice_function(x, y): 3\nX and Y didn't change: (1, 2)\nReason: int is immutable\nnice_function(a, b): [1, 2, 3, 4]\nA and B change: ([1, 2, 3, 4], [3, 4])\nReason: list is mutable\n</code></pre>"},{"location":"functions/parameters/#default-arguments","title":"Default Arguments","text":"default_arguments.py<pre><code>&gt;&gt;&gt; def nice_some(a = 2, b =2):\n...     # int is immutable, SO ALL GOOD!\n...     return a + b\n&gt;&gt;&gt; print(nice_some())\n&gt;&gt;&gt; print(nice_some(50))\n&gt;&gt;&gt; print(nice_some(50, 50))\n4\n52\n100\n</code></pre>"},{"location":"functions/parameters/#mutable-types-as-deafults-bad-idea","title":"Mutable Types as Deafults: Bad Idea","text":"<p>Default values in Python functions are evaluated at the time of function definition, in the defining scope. As a result, the <code>default value is evaluated only once</code>, and this becomes significant when the default value is a mutable object, like a list, dictionary, or instances of most classes.</p> <p>If a default value is a mutable object, and you <code>modify it within the function, the change will affect all future calls to the function</code>. This is because instances that don't receive an initial value for a mutable default parameter end up sharing the same variable reference.</p> <p>To avoid unexpected behavior, it's common to use None as the default value for parameters that may receive mutable values. By doing so, you ensure that each call to the function receives its independent mutable object, preventing any unintended side effects across different function calls.</p> default_mutable_arguments.py<pre><code>&gt;&gt;&gt; def f(a, L=[]):\n...    L.append(a)\n...    return L\n&gt;&gt;&gt; print(f(1))\n&gt;&gt;&gt; print(f(2))\n&gt;&gt;&gt; print(f(3))\n[1]\n[1, 2]\n[1, 2, 3]\n</code></pre> src/functions/deep_mutable_arg.py<pre><code>## Take from Fluent Python, 2nd Edition (https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/)\nclass TwilightBusWrong:\ndef __init__(self, passengers=None):\nif passengers is None:\nself.passengers = []  \nelse:\n# create a aliases for list passed\nself.passengers = passengers  \ndef pick(self, name):\nself.passengers.append(name)\ndef drop(self, name):\nself.passengers.remove(name)\nclass TwilightBusRight:\ndef __init__(self, passengers=None):\nif passengers is None:\nself.passengers = []\nelse:\n# create a new LIST, making a copy from list passed\nself.passengers = list(passengers) \ndef pick(self, name):\nself.passengers.append(name)\ndef drop(self, name):\nself.passengers.remove(name)\n</code></pre>"},{"location":"functions/parameters/#positional-or-keyword-parameters","title":"Positional or Keyword Parameters","text":"<p>If the parameter type (positional or keyword) is not explicitly specified, it is possible to pass the argument in both ways.</p> positional_keyword.py<pre><code>&gt;&gt;&gt; def example_function(a, b, c):\n...    print(a, b, c)\n&gt;&gt;&gt; # Both ways of calling the function are valid:\n&gt;&gt;&gt; example_function(1, 2, 3)       # Positional arguments\n&gt;&gt;&gt; example_function(c=3, b=2, a=1) # Keyword arguments\n1 2 3\n1 2 3\n</code></pre>"},{"location":"functions/parameters/#positional-only-parameters","title":"Positional-Only Parameters","text":"<p>Positional-only parameters in Python functions are ordered in a way that their <code>sequence matters</code>, and they cannot be passed using keywords. These parameters are designated by being <code>placed before a forward-slash (/) in the function definition</code>. The forward-slash serves as a logical separator, indicating the boundary between the positional-only parameters and the rest of the parameters.</p> positional_only.py<pre><code>&gt;&gt;&gt; def example_function(a, b, /, c, d):\n...     print(a, b, c, d)\n... # Calling the function using positional arguments only:\n&gt;&gt;&gt; example_function(1, 2, 3, 4)\n... # Using positional and keyword arguments together:\n&gt;&gt;&gt; example_function(3, 1, c=2, d=7)\n... # example_function(3, b=1, c=2, d=7) b=1 generates an error because B cannot be keyword\n1 2 3 4\n3 1 2 7\n</code></pre>"},{"location":"functions/parameters/#keyword-only-parameters","title":"Keyword-Only Parameters","text":"<p>To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, place an <code>* in the arguments list just before the first keyword-only parameter</code>.</p> keyword_only.py<pre><code>&gt;&gt;&gt; def example_function(a, b, *, c, d):\n...     print(a, b, c, d)\n... # Calling the function using positional arguments only:\n&gt;&gt;&gt; example_function(1, 2, c=3, d=4)\n... # Using positional and keyword arguments together:\n&gt;&gt;&gt; example_function(3, b=1, c=2, d=7) # No problem, just C and D NEEDS to be keyword\n... # example_function(3, 1, 2, d=7) ERROR C is not Keyword\n1 2 3 4\n3 1 2 7\n</code></pre>"},{"location":"functions/parameters/#positional-and-keyword-parameters","title":"Positional and Keyword Parameters","text":"<p>If <code>/</code> and <code>*</code> are not present in the function definition, arguments may be passed to a function by position or by keyword.</p> <pre><code>def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n      -----------    ----------     ----------\n        |             |                  |\n        |        Positional or keyword   |\n        |                                - Keyword only\n         -- Positional only\n</code></pre>"},{"location":"functions/parameters/#arbitrary-argument-lists","title":"Arbitrary Argument Lists","text":"<p>Python functions can be defined to <code>accept an arbitrary number of arguments by using the asterisk (*) symbol before the parameter name</code>. This allows the function to be called with any number of arguments, and these arguments will be <code>bundled together into a tuple.</code></p> arbitrary_args.py<pre><code>&gt;&gt;&gt; def write_multiple_items(file, separator, *args):\n...    file.write(separator.join(args))\n</code></pre> <p>Normally, these arbitrary argumen are typically placed last in the list of formal parameters of a function. This allows them to collect any additional input arguments that are passed to the function. <code>After the *args parameter, any subsequent formal parameters are considered 'keyword-only' arguments</code>, which means they can only be used as keywords when calling the function, rather than being passed as positional arguments.</p> arbitrary_args2.py<pre><code>&gt;&gt;&gt; def example_function(a, b, *args, c, d):\n...    print(f\"a: {a}, b: {b}\")\n...    print(f\"Additional arguments {args}, type {type(args)}\")\n...    print(f\"c: {c}, d: {d}\")\n&gt;&gt;&gt; example_function(1, 2, 3, 4, 5, c=6, d=7)\n&gt;&gt;&gt; example_function(10, 20, c=30, d=40)\na: 1, b: 2\nAdditional arguments (3, 4, 5), type &lt;class 'tuple'&gt;\nc: 6, d: 7\na: 10, b: 20\nAdditional arguments (), type &lt;class 'tuple'&gt;\nc: 30, d: 40\n</code></pre>"},{"location":"functions/parameters/#unpacking-argument-lists","title":"Unpacking Argument Lists","text":"unpacking_args.py<pre><code>&gt;&gt;&gt; def parrot(voltage, state='a stiff', action='voom'):\n...    print(\"-- This parrot wouldn't\", action, end=' ')\n...    print(\"if you put\", voltage, \"volts through it.\", end=' ')\n...    print(\"E's\", state, \"!\")\n&gt;&gt;&gt; d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n&gt;&gt;&gt; parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n</code></pre>"},{"location":"functions/parameters/#references","title":"References","text":"<ul> <li> <p>Python - 4.8. More on Defining Functions</p> </li> <li> <p>Fluent Python, 2nd Edition</p> </li> </ul>"},{"location":"functions/type_hits/","title":"Type Hits in Functions","text":""},{"location":"functions/user_defined_callable_types/","title":"User-Defined Callable Types","text":"<p>In Python, we can make arbitrary objects behave like functions by implementing a <code>__call__</code> instance method. This simple approach allows us to create function-like objects with internal state that persists across invocations. By defining the <code>__call__</code> method, we enable instances of the class to be callable, just like regular functions.</p> user_callable_object.py<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; class BingoCage:\n&gt;&gt;&gt;     def __init__(self, items):\n...        self._items = list(items)  \n...        random.shuffle(self._items)  \n&gt;&gt;&gt;     def pick(self):\n...        try:\n...            return self._items.pop()\n...        except IndexError:\n...            raise LookupError('pick from empty BingoCage')  \n&gt;&gt;&gt;     def __call__(self):\n...        return self.pick()\n&gt;&gt;&gt; bingo = BingoCage(range(3))\n&gt;&gt;&gt; print(bingo.pick())\n&gt;&gt;&gt; print(bingo())\n&gt;&gt;&gt; print(callable(bingo))\n0\n1\nTrue\n</code></pre>"},{"location":"functions/user_defined_callable_types/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> </ul>"},{"location":"functions/variables_scope/","title":"Variables Scope","text":"<p>Taking as example, this code:</p> var_scope.py<pre><code>&gt;&gt;&gt; num = 2\n&gt;&gt;&gt; def var_scope(num_fun):\n...     print(num_fun)\n...     try:\n...         print(num)\n...         num = 10\n...     except BaseException as err:\n...         print(err)\n&gt;&gt;&gt; var_scope(5)\n5\ncannot access local variable 'num' where it is not associated with a value\n</code></pre> <p>You may notice that <code>print(num_fun)</code> was executed successfully, while <code>print(num) raised an exception</code>, even though <code>num was initialized outside the function</code>. The reason behind this is that when Python compiles the function's body, <code>it identifies num as a local variable because it gets assigned within the function</code>. So, when the function <code>var_scope is called</code>, it can access and print the value of the local variable <code>num_fun</code>. However, when it attempts to access the <code>local variable num, it encounters an issue because b is not bound</code>.</p> <p>In Python, there's <code>no requirement to declare variables explicitly</code>, but the <code>interpreter assumes that a variable assigned within a function is local</code>. If you want the interpreter to treat b as a global variable and still assign a new value to it within the function, you need to use the global declaration.</p> var_scope_global.py<pre><code>&gt;&gt;&gt; num = 2\n&gt;&gt;&gt; def var_scope(num_fun):\n...     global num\n...     print(num_fun)\n...     try:\n...         print(num)\n...         num = 10\n...     except BaseException as err:\n...         print(err)\n&gt;&gt;&gt; var_scope(5)\n&gt;&gt;&gt; print(num)\n5\n2\n10\n</code></pre>"},{"location":"functions/variables_scope/#types-of-scope","title":"Types of Scope","text":"<ol> <li> Module Global Scope Made of names assigned to values <code>outside of any class or function block</code>. </li> <li> Function Local Scope Made of names assigned to values as <code>parameters, or directly in the body of the function</code>. </li> <li> Nonlocal Scope The nonlocal scope refer to all those variables that are <code>declared within nested functions</code>. The <code>nonlocal keyword is used to work with variables inside nested functions</code>, where the variable should not belong to the inner function. It lets you declare a variable as a <code>free variable</code>. </li> </ol>"},{"location":"functions/variables_scope/#variable-lookup-logic","title":"Variable Lookup Logic","text":"<p>When defining a function, the Python decides how to access a variable like <code>x</code> within it, following these rules for each situation:</p>"},{"location":"functions/variables_scope/#referenced-and-assigned","title":"Referenced and Assigned","text":"<ol> <li>If there's a <code>global x</code> declaration, the x variable is <code>fetched from and assigned to the global variable x in the module</code>;</li> <li>When a <code>nonlocal x</code> declaration is present, x is <code>taken from and assigned to the local variable x</code> within the closest surrounding function where x is defined;</li> <li>If <code>x is either a parameter or assigned a value within the function body</code>, it becomes the local variable.</li> </ol>"},{"location":"functions/variables_scope/#just-referenced-and-is-not-a-parameter","title":"Just Referenced and is not a Parameter","text":"<ol> <li>x will be <code>searched in nonlocal scopes</code>. So, in the local scopes of the enclosing function bodies;</li> <li>If not in nonlocal scopes, x will be <code>searched in the module global scope</code>;</li> <li>If not in module global scope, x will be <code>searched in the __builtins__.__dict__</code>;</li> </ol>"},{"location":"functions/variables_scope/#comparing-bytecodes","title":"Comparing bytecodes","text":"bytecodes_compare.py<pre><code>&gt;&gt;&gt; num = 2\n&gt;&gt;&gt; def var_scope_right(num_fun):\n...     global num\n...     print(num_fun)\n...     try:\n...         print(num)\n...         num = 10\n...     except BaseException as err:\n...         print(err)\n&gt;&gt;&gt; def var_scope_wrong(num_fun):\n...     print(num_fun)\n...     try:\n...         print(num)\n...         num = 10\n...     except BaseException as err:\n...         print(err)\n&gt;&gt;&gt; from dis import dis\n&gt;&gt;&gt; print(dis(var_scope_right)) # Don't know why is not working\n&gt;&gt;&gt; dis(var_scope_wrong) # Don't know why is not working\nNone\n</code></pre>"},{"location":"functions/variables_scope/#references","title":"References","text":"<ul> <li>Fluent Python, 2nd Edition</li> <li>Python - 4.8. More on Defining Functions</li> <li>Python nonlocal Keyword</li> </ul>"}]}