{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Python","text":"<p>A particular but not private repository to centralize all studies about Python and a few famous Python's libraries. It's kind my own documentation about the language. </p>"},{"location":"#python-versions-supported","title":"Python Versions Supported","text":"<ul> <li>Python 3.11 or lower</li> </ul>"},{"location":"#backlog","title":"Backlog","text":"<ul> <li>Python 3.12 news</li> </ul>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>W3Schools - Python</li> <li>Fluent Python, 2nd Edition</li> <li>Python - Documentation</li> </ul> <p>*and of course chatGPT </p>"},{"location":"basics/control_flow/","title":"Control Flow","text":"<p>Listing the fundamental and commonly used control flow structures in Python.</p>"},{"location":"basics/control_flow/#if","title":"if","text":"if.py<pre><code>&gt;&gt;&gt; x = 42\n&gt;&gt;&gt; if x &lt; 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\nMore\n</code></pre>"},{"location":"basics/control_flow/#short-hand-if","title":"Short hand if","text":"short_if.py<pre><code>&gt;&gt;&gt; a = 25\n&gt;&gt;&gt; b = 15\n&gt;&gt;&gt; if a &gt; b: print(\"A is greater than B\")\n&gt;&gt;&gt; print(\"B\") if a &lt;= b else print(\"A\")\nA is greater than B\nA\n</code></pre>"},{"location":"basics/control_flow/#while","title":"while","text":"while.py<pre><code>&gt;&gt;&gt; n = 5\n&gt;&gt;&gt; while n &gt; 1:\n...     print(n)\n...     n = n - 1\n5\n4\n3\n2\n</code></pre>"},{"location":"basics/control_flow/#for","title":"for","text":"for.py<pre><code>&gt;&gt;&gt; words = ['cat', 'window', 'defenestrate']\n&gt;&gt;&gt; for w in words:\n...    print(w, len(w))\ncat 3\nwindow 6\ndefenestrate 12\n</code></pre>"},{"location":"basics/control_flow/#range","title":"range","text":"range.py<pre><code>&gt;&gt;&gt; for i in range(3):\n...    print(i)\n... print(\"range(3)---------&gt;\")\n&gt;&gt;&gt; for i in range(5, 10):\n...    print(i)\n... print(\"range(5, 10)---------&gt;\")\n&gt;&gt;&gt; for i in range(0, 10, 2):\n...    print(i)\n... print(\"range(0, 10, 2)---------&gt;\")\n&gt;&gt;&gt; a = ['Mary', 'had', 'a', 'little', 'lamb']\n&gt;&gt;&gt; for i in range(len(a)):\n...    print(i, a[i])\n... print(\"range(len(a))---------&gt;\")\n0\n1\n2\nrange(3)---------&gt;\n5\n6\n7\n8\n9\nrange(5, 10)---------&gt;\n0\n2\n4\n6\n8\nrange(0, 10, 2)---------&gt;\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\nrange(len(a))---------&gt;\n</code></pre>"},{"location":"basics/control_flow/#try","title":"try","text":"try.py<pre><code>&gt;&gt;&gt; try:\n...    zero_division = 10 / 0\n... except ZeroDivisionError as zero_error:\n...     print(f\"ERROR: {zero_error}\")\n... except:\n...     print(\"Global except clause\")\n... finally:\n...     print(\"Justing print the finally\")\nERROR: division by zero\nJusting print the finally\n</code></pre>"},{"location":"basics/control_flow/#break-continue-and-else-on-loops","title":"break, continue and else on loops","text":"<ul> <li>The break statement breaks out the innermost enclosing for or while loop.</li> <li>The else statement in loops is executed when the loop terminates through exhaustion, but not when the loop is terminated by a break statement.</li> </ul> break_else.py<pre><code>&gt;&gt;&gt; for n in range(2, 10):\n&gt;&gt;&gt;    for x in range(2, n):\n...        if n % x == 0:\n...            print(n, 'equals', x, '*', n//x)\n...            break\n...    else:\n...        # loop fell through without finding a factor\n...        print(n, 'is a prime number')\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n</code></pre> <ul> <li>The continue statement continues with the next iteration of the loop.</li> </ul> continue.py<pre><code>&gt;&gt;&gt; for num in range(2, 10):\n&gt;&gt;&gt;    if num % 2 == 0:\n...        print(\"Found an even number\", num)\n...        continue\n...    print(\"Found an odd number\", num)\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n</code></pre>"},{"location":"basics/control_flow/#match","title":"match","text":"<ul> <li>A match statement takes an exmpression and compares its value to sucessive patterns using the case blocks.</li> <li>This is similar to a switch statement but it's more similiar to patter matching.</li> <li>Only the first pattern that matches gets executed.</li> <li>There are many use cases that will be explorer more in this documentation.</li> </ul> match.py<pre><code>&gt;&gt;&gt; def http_error(status):\n&gt;&gt;&gt;    match status:\n...        case 400:\n...            return \"Bad request\"\n...        case 404:\n...            return \"Not found\"\n...        case 418:\n...            return \"I'm a teapot\"\n...        case _:\n...            return \"Something's wrong with the internet\"\n</code></pre>"},{"location":"basics/control_flow/#references","title":"References","text":"<ul> <li>Python - 8. Compound statements</li> <li>Python - 4. More Control Flow Tools</li> </ul>"},{"location":"basics/exception/","title":"Exception Handling","text":"<p>To ensure consistency and proper handling, all exceptions must be instances of a class that derives from the BaseException class. This principle helps maintain code clarity and enables developers to catch and respond to specific error scenarios effectively.</p>"},{"location":"basics/exception/#handiling-exceptions","title":"Handiling Exceptions","text":""},{"location":"basics/exception/#selected-exception","title":"Selected Exception","text":"selecet_exc.py<pre><code>&gt;&gt;&gt; try:\n...     x = \"hello\"\n...     y = sum(x)\n... except TypeError:\n...     print(\"Operation invalid\")\nOperation invalid\n</code></pre>"},{"location":"basics/exception/#multiple-handlers-expcetions","title":"Multiple Handlers Expcetions","text":"multi_selecet_exc.py<pre><code>&gt;&gt;&gt; try:\n...     x = \"hello\"\n...     z = x / 2\n...     y = sum(x)\n... except (ValueError, TypeError, NameError):\n...     print(\"Operation invalid\")\n...     print()\nOperation invalid\n</code></pre> multi_selecet_exc2.py<pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; try:\n...    f = open('myfile.txt')\n...    s = f.readline()\n...    i = int(s.strip())\n... except OSError as err:\n...    print(\"OS error: {0}\".format(err))\n... except ValueError:\n...    print(\"Could not convert data to an integer.\")\n... except BaseException as err:\n...    print(f\"Unexpected {err=}, {type(err)=}\")\n...    raise\nOS error: [Errno 2] No such file or directory: 'myfile.txt'\n</code></pre>"},{"location":"basics/exception/#baseexceptions-as-a-wildcard","title":"BaseExceptions as a Wildcard","text":"<p>By virtue of all exceptions inheriting from BaseException, it is possible to utilize the \"except\" statement to capture any exception.</p> base_exc.py<pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; try:\n...    f = open('myfile.txt')\n...    s = f.readline()\n...    i = int(s.strip())\n... except BaseException as err:\n...    print(f\"Unexpected {err=}, {type(err)=}\")\nUnexpected err=FileNotFoundError(2, 'No such file or directory'), type(err)=&lt;class 'FileNotFoundError'&gt;\n</code></pre>"},{"location":"basics/exception/#exception-properties-analyses","title":"Exception Properties Analyses","text":"base_exc.py<pre><code>&gt;&gt;&gt; try:\n...    raise Exception('spam', 'eggs')\n... except Exception as inst:\n...    print(type(inst))\n...    print(inst.args)\n...    x, y = inst.args\n...    print('x =', x)\n...    print('y =', y)\n&lt;class 'Exception'&gt;\n('spam', 'eggs')\nx = spam\ny = eggs\n</code></pre>"},{"location":"basics/exception/#raise-exceptions","title":"Raise Exceptions","text":"<pre><code>raise ValueError  # shorthand for 'raise ValueError()'\n</code></pre> <pre><code>try:\nraise NameError('Hi There')\nexcept NameError:\nprint('An exception flew by!')\nraise\n</code></pre>"},{"location":"basics/exception/#exceptions-chaining","title":"Exceptions Chaining","text":"<p>The raise statement in Python enables the option of chaining exceptions, facilitating error handling and flow control within the code.</p> exc_chaning.py<pre><code>&gt;&gt;&gt; def func():\n...    raise ConnectionError\n&gt;&gt;&gt; try:\n...    func()\n... except ConnectionError as exc:\n...    raise RuntimeError('Failed to open database') from exc\n</code></pre> exc_chaning_result.py<pre><code>Traceback (most recent call last):\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 4, in &lt;module&gt;\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"/home/gabriel/Projects/mastering-python/venv/lib/python3.11/site-packages/markdown_exec/formatters/python.py\", line 59, in _run_python\nexec(compiled, exec_globals)  # noqa: S102\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nFile \"&lt;code block: n15; title exc_chaning_result.py&gt;\", line 6, in &lt;module&gt;\nraise RuntimeError('Failed to open database') from exc\nRuntimeError: Failed to open database\n</code></pre>"},{"location":"basics/exception/#user-definied-exceptions","title":"User-definied Exceptions","text":"<p>When creating user-defined exceptions, it is essential to ensure they are derived either directly or indirectly from the built-in Exception class. Conventionally, these custom exceptions are named with endings such as \"Error,\" following a clear and descriptive naming pattern for enhanced code readability.</p> db_exception.py<pre><code>from dataclasses import dataclass, field\n@dataclass\nclass DatabaseConnectionError(Exception):\nmessage: str = field(init=False, default=\"Couldn't connect to database\")\n</code></pre>"},{"location":"basics/exception/#references","title":"References","text":"<ul> <li>Python Exceptions</li> <li>Python Built-in Exceptions</li> <li>Real Python Exceptions</li> </ul>"},{"location":"basics/modules_packages/","title":"Modules and Packages","text":""},{"location":"basics/modules_packages/#modules","title":"Modules","text":"<p>In Python, a module is essentially a file that contains various definitions and statements. The module name corresponds to the file name without the .py extension. Within a module, the module's name (as a string) is available as the value of the global variable <code>__name__</code>.</p> <p>When importing modules, if the imported module names are placed at the top level of a file (outside any function or class), they are added to the module's global namespace. This allows easy access to the functions, variables, or classes defined within the imported modules.</p> <p>In addition to Python-written modules, you can also define a folder as a module by including a file called init.py within it. This folder then becomes a module that can be imported and utilized.</p> modules.py<pre><code># import module 'dataclasses' to current namespaces\nimport dataclasses\n# import names (dataclass, field) to current namespaces\nfrom dataclasses import dataclass, field \n# import all names from the module,\n# except those beginning with underscore on the name\nfrom dataclasses import *\n</code></pre>"},{"location":"basics/modules_packages/#absolute-imports","title":"Absolute imports","text":"<p>An absolute import refers to a type of import where the location of the classes being imported is fully specified. This allows for a clear and unambiguous reference to the desired import location, ensuring that there is no confusion or conflict with other modules or classes that may have the same name but reside in different packages or directories.</p> abs_import.py<pre><code># from PACKAGE.MODULE.MODULE import CLASS\nfrom pandas.core.frame import DataFrame\n# import PACKAGE.MODULE.MODULE\nimport pandas.core.frame as frame\nexample = frame.DataFrame()\n# from PACKAGE.MODULE import MODULE \nfrom pandas.core import frame\n</code></pre>"},{"location":"basics/modules_packages/#relative-imports","title":"Relative imports","text":"<p>Relative imports allow us to specify the location of the classes being imported relative to the current package or module. By using relative import statements, we can reference and import classes from modules located within the same package or subpackages, providing a concise and context-aware way to import and utilize code within the project's structure.</p> <ul> <li>Current directory: <code>.</code></li> <li>Previous directory: <code>..</code></li> </ul> <pre>\n\u2514\u2500\u2500 not_nice_import.py\n    \u251c\u2500\u2500 relative_import.py\n    \u251c\u2500\u2500 nice_file.py\n</pre> relative_import.py<pre><code># if the files are in the same place\nfrom .nice_file import add_func\n# if the file calling is one directory down\nfrom ..not_nice_import import not_nice_add_func\n</code></pre>"},{"location":"basics/modules_packages/#impact-of-init-file","title":"Impact of init file","text":"<pre>\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 calculator_func\n        \u251c\u2500\u2500 __init_.py\n        \u251c\u2500\u2500 add_func.py\n        \u251c\u2500\u2500 sub_func.py\n        \u251c\u2500\u2500 mul_func.py\n        \u251c\u2500\u2500 div_func.py\n    \u251c\u2500\u2500 calculator.py\n</pre> __init__.py<pre><code>from .add_func import add_func\nfrom .sub_func import sub_func\nfrom .mul_func import mul_func\nfrom .div_func import div_func\n</code></pre> calculator.py<pre><code># instead of\nfrom calculator_func.add_func import add_func\nfrom calculator_func.sub_func import sub_func\n# possible to import\nfrom calculator_func import add_func, sub_func, mul_func, div_func\n</code></pre>"},{"location":"basics/modules_packages/#executing-modules-as-scripts","title":"Executing modules as scripts","text":"<p>In Python, any file that contains a module is also considered a Python script and can be executed when imported. However, by including the following code block, it prevents the module from executing when imported, allowing the file to be used both as a standalone script and as an importable module:</p> import_main.py<pre><code>if __name__ == \"__main__\":\n# Code to be executed when the script is run directly\npass\n</code></pre> <p>This usage of the <code>__name__</code> variable ensures that the code block under the if statement is only executed when the file is run directly as a script, rather than being imported as a module. This distinction allows the file to serve dual purposes, functioning as an executable script or an importable module based on how it is invoked.</p>"},{"location":"basics/modules_packages/#packages","title":"Packages","text":"<p>In Python, a package is a collection of modules that enables hierarchical structuring of the module namespace using dot notation. They help prevent naming collisions between modules by providing a way to create a nested structure for modules. Similar to how modules mitigate conflicts in global variable names, packages ensure that module names remain distinct and avoid clashes within the project's namespace. This hierarchical organization enhances code readability, maintainability, and reduces the risk of naming conflicts.</p>"},{"location":"basics/modules_packages/#difference-when-use-from-and-import","title":"Difference when use <code>from</code> and <code>import</code>","text":"from_import.py<pre><code># item can be either a submodule, or some other name defined in the package,\n# like a function, class or variable\nfrom package import item\n# item MUST BE a package. subitem can be a module or a package\n# but can't be a class or function\nimport package.item.subitem\n</code></pre>"},{"location":"basics/modules_packages/#importing-from-a-package","title":"Importing * from a Package","text":"<p>Importing everything using the <code>*</code> notation in Python packages can lead to lengthy import times and unintended side effects. It is generally not recommended to import all modules from a package in this manner. However, you can specify which modules should be imported when using <code>from package import *</code>, you can define a list named <code>__all__</code> in the <code>__init__</code>.py file of the package.</p> __init__with_all.py<pre><code>from .add_func import add_func\nfrom .sub_func import sub_func\nfrom .mul_func import mul_func\nfrom .div_func import div_func\n__all__ = [\n\"add_func\",\n\"sub_func\",\n\"mul_func\",\n\"div_func\",\n]\n</code></pre>"},{"location":"basics/modules_packages/#references","title":"References","text":"<ul> <li>Python Modules doc</li> <li>Real Python Modules and Packages</li> </ul>"},{"location":"basics/operators/","title":"Python Operators","text":""},{"location":"basics/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li>Addition: +</li> <li>Subtraction: -</li> <li>Multiplication: *</li> <li>Division: /</li> <li>Floor Division: //</li> <li>Modulus: %</li> <li>Exponentiation: **</li> </ul> arith_operators.py<pre><code>&gt;&gt;&gt; addition = 123 + 123\n&gt;&gt;&gt; subtraction = 123 - 123\n&gt;&gt;&gt; multi = 123 * 123\n&gt;&gt;&gt; division = 123 / 123\n&gt;&gt;&gt; floor_division = 25 // 5\n&gt;&gt;&gt; print(f\"floor_division by 25/5: {floor_division}\")\n&gt;&gt;&gt; floor_division = 25 // 6\n&gt;&gt;&gt; print(f\"floor_division by 25/6: {floor_division}\")\n&gt;&gt;&gt; modulus = 25 % 5\n&gt;&gt;&gt; print(f\"modulus by 25/5: {modulus}\")\n&gt;&gt;&gt; modulus = 25 % 6\n&gt;&gt;&gt; print(f\"modulus by 25/6: {modulus}\")\n&gt;&gt;&gt; exponentiation = 2 ** 2\n&gt;&gt;&gt; print(f\"exponentiation: {exponentiation}\")\nfloor_division by 25/5: 5\nfloor_division by 25/6: 4\nmodulus by 25/5: 0\nmodulus by 25/6: 1\nexponentiation: 4\n</code></pre>"},{"location":"basics/operators/#assignment-operators","title":"Assignment Operators","text":"<ul> <li>Assignment: =</li> <li>Addition Assignment: +=</li> <li>Subtraction Assignment: -=</li> <li>Multiplication Assignment: *=</li> <li>Division Assignment: /=</li> <li>Floor Division Assignment: //=</li> <li>Modulus Assignment: %=</li> <li>Exponentiation Assignment: **=</li> </ul>"},{"location":"basics/operators/#comparison-operators","title":"Comparison Operators","text":"<ul> <li>Equal to: ==</li> <li>Not equal to: !=</li> <li>Greater than: &gt;</li> <li>Less than: &lt;</li> <li>Greater than or equal to: &gt;=</li> <li>Less than or equal to: &lt;=</li> </ul>"},{"location":"basics/operators/#logical-operators","title":"Logical Operators","text":"<ul> <li>Logical AND: and</li> <li>Logical OR: or</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>Bitwise operators are used to perform operations on individual bits of binary numbers. They treat numbers as sequences of binary digits (bits) and operate on them bit by bit.</p> <ul> <li> <p>Bitwise AND: &amp;</p> <p>Performs a logical AND operation on each pair of corresponding bits. If both bits are 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise OR: |</p> <p>Performs a logical OR operation on each pair of corresponding bits. If at least one bit is 1, the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise XOR: ^</p> <p>Performs a logical XOR (exclusive OR) operation on each pair of corresponding bits. If the two bits are different (one is 0 and the other is 1), the result is 1. Otherwise, the result is 0.</p> </li> <li> <p>Bitwise NOT: ~</p> <p>Inverts (flips) the bits of a number. Changes each 1 to 0 and each 0 to 1.</p> </li> <li> <p>Left Shift: &lt;&lt;</p> <p>Shifts the bits of a number to the left by a specified number of positions. The empty positions on the right are filled with zeros. Each shift to the left is equivalent to multiplying the number by 2.</p> </li> <li> <p>Right Shift: &gt;&gt;</p> <p>Shifts the bits of a number to the right by a specified number of positions. The empty positions on the left are filled with the sign bit (0 for positive numbers, 1 for negative numbers). Each arithmetic shift to the right is equivalent to dividing the number by 2.</p> </li> </ul> <p>Bitwise operators are commonly used in low-level programming, networking, and manipulation of binary data. They allow you to manipulate individual bits within numbers, set or clear specific flags, or extract information from bit patterns.</p>"},{"location":"basics/operators/#membership-operators","title":"Membership Operators","text":"<ul> <li>In: in</li> <li>Not in: not in</li> </ul>"},{"location":"basics/operators/#identity-operators","title":"Identity Operators","text":"<ul> <li>Is: is</li> <li>Is not: is not</li> </ul>"},{"location":"basics/operators/#unary-operators","title":"Unary Operators","text":"<ul> <li>Positive: +</li> <li>Negative: -</li> <li>Logical NOT: not</li> </ul>"},{"location":"basics/operators/#ternary-operator","title":"Ternary Operator","text":"<ul> <li>Conditional Expression: a if condition else b</li> </ul> ternary.py<pre><code>&gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 20\n&gt;&gt;&gt; print(a if a &gt; b else b)\n20\n</code></pre>"},{"location":"basics/python_paradigm/","title":"Python's Paradigms and Way of Work","text":"<p>It supports multiple programming paradigms and follows a specific way of working.Python's paradigms encompass dynamic typing, support for object-oriented and functional programming, garbage collection for memory management, emphasis on readability and expressiveness, and a rich standard library. These features contribute to Python's popularity and make it a flexible language for diverse programming needs. Here are some key aspects of Python's paradigms and its way of work:</p> <ul> <li> <p>Dynamic Typing System: Python uses a dynamic typing system, which means you don't need to explicitly declare variable types. You can assign values of different types to the same variable, and Python determines the type during runtime. This flexibility allows for quick prototyping and easy code modification.</p> </li> <li> <p>Object-Oriented Programming (OOP): Python fully supports object-oriented programming. It provides classes, objects, and inheritance, allowing you to create reusable and modular code. Encapsulation, polymorphism, and inheritance are core principles of OOP that Python encourages.</p> </li> <li> <p>Functional Programming: Python also supports functional programming paradigms. Functions are first-class citizens, which means you can assign them to variables, pass them as arguments, and return them as values. Python provides built-in higher-order functions like map, filter, and reduce, making it easier to write functional-style code.</p> </li> <li> <p>Imperative Programming: Python is primarily an imperative programming language. It follows a sequential execution model, where statements are executed in the order they appear. You can use control flow statements like if-else, loops, and switch-case to control the flow of execution.</p> </li> <li> <p>Garbage Collection: Python has an automatic garbage collector that manages memory allocation and deallocation. It frees developers from manual memory management tasks like allocating and releasing memory. The garbage collector identifies unused objects and reclaims the memory occupied by them, making Python memory-efficient.</p> </li> <li> <p>Extensive Standard Library: Python comes with a comprehensive standard library that offers a wide range of modules and functions for various purposes. The standard library provides ready-to-use solutions for common tasks, reducing the need for writing code from scratch. It enables developers to be productive and efficient.</p> </li> </ul>"},{"location":"basics/variables_and_datatypes/","title":"Variables and Data Types","text":"<p>In Python, variables can refer to different types of data, enabling us to manipulate that data as needed. To facilitate this, Python offers a range of standard data types that are specifically designed for storing and manipulating various kinds of data.</p>"},{"location":"basics/variables_and_datatypes/#variables","title":"Variables","text":"<p>One of the most notable and distinct features of variables in Python is their dynamic typing. This means that a single variable can change its type as required during the execution of the program.</p> variables.py<pre><code>&gt;&gt;&gt; nice_var = 123\n&gt;&gt;&gt; print(type(nice_var))\n&gt;&gt;&gt; nice_var = \"now I'm a string\"\n&gt;&gt;&gt; print(type(nice_var))\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#data-types","title":"Data Types","text":"<p>Python categorizes data types into the following categories: Text, Numeric, Sequence, Mapping, Set, Boolean, and Binary types. These categories encompass the various types of data that Python can handle.</p>"},{"location":"basics/variables_and_datatypes/#text-type","title":"Text Type","text":"<ul> <li>str: Represents a sequence of characters, such as \"hello\" or \"Python\". Strings are immutable.</li> </ul> text.py<pre><code>&gt;&gt;&gt; string_var = \"Corinthians please help me\"\n&gt;&gt;&gt; print(string_var)\n&gt;&gt;&gt; print(type(string_var))\nCorinthians please help me\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#numeric-type","title":"Numeric Type","text":"<ul> <li>str: Represents integers (whole numbers) like 5, -3, 100.</li> <li>float: Represents floating-point numbers with decimal places like 3.14, -0.5, 2.0.</li> </ul> numeric.py<pre><code>&gt;&gt;&gt; int_number = 1910\n&gt;&gt;&gt; print(int_number)\n&gt;&gt;&gt; print(type(int_number))\n&gt;&gt;&gt; print(int_number + 2)\n&gt;&gt;&gt; float_number = int_number + 0.3\n&gt;&gt;&gt; print(float_number)\n&gt;&gt;&gt; print(type(float_number))\n1910\n&lt;class 'int'&gt;\n1912\n1910.3\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#sequence-type","title":"Sequence Type","text":"<ul> <li>list: Represents an ordered collection of elements enclosed in square brackets ([]). Lists can contain elements of different data types and are mutable, meaning you can modify them.</li> <li>tuple: Similar to lists, tuples represent an ordered collection of elements enclosed in parentheses (()). However, tuples are immutable, meaning they cannot be modified once created.</li> <li>range: Python provides a built-in range() function that generates a sequence of numbers within a specified range. The range() function is commonly used in loops and iterations.</li> </ul> sequence.py<pre><code>&gt;&gt;&gt; my_list = list([1, 2, 3, 4])\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; my_list = [5, 6, 7, 8]\n&gt;&gt;&gt; print(my_list)\n&gt;&gt;&gt; print(type(my_list))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_tuple = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; my_tuple = tuple((1, 2, 3, 4, 5)) # cannot tuple(1, 2, 3, 4, 5)\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"Tuple with only one element\")\n&gt;&gt;&gt; my_tuple = (1,) # or tuple((1,))\n&gt;&gt;&gt; print(my_tuple)\n&gt;&gt;&gt; print(type(my_tuple))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_range = range(1, 5)\n&gt;&gt;&gt; for num in my_range:\n&gt;&gt;&gt;     print(f\"num value: {num}\")\n[1, 2, 3, 4]\n&lt;class 'list'&gt;\n[5, 6, 7, 8]\n&lt;class 'list'&gt;\n---------------------------&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\n(1, 2, 3, 4, 5)\n&lt;class 'tuple'&gt;\nTuple with only one element\n(1,)\n&lt;class 'tuple'&gt;\n---------------------------&gt;\nnum value: 1\nnum value: 2\nnum value: 3\nnum value: 4\n</code></pre>"},{"location":"basics/variables_and_datatypes/#mapping-type","title":"Mapping Type","text":"<ul> <li>dictionary (dict): Represents a collection of key-value pairs enclosed in curly braces ({}) or created using the dict() constructor. Dictionaries provide a way to store and retrieve data using unique keys.</li> </ul> dict.py<pre><code>&gt;&gt;&gt; my_dict = {\"name\" : \"Gabriel\", \"age\" : 25}\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n&gt;&gt;&gt; my_dict = dict(name=\"Gabriel\", age=25)\n&gt;&gt;&gt; print(my_dict)\n&gt;&gt;&gt; print(type(my_dict))\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n{'name': 'Gabriel', 'age': 25}\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#set-data-types","title":"Set Data Types","text":"<ul> <li>set: Represents an unordered collection of unique elements enclosed in curly braces ({}) or created using the set() constructor. Sets are useful to perform operations like union, intersection, and difference.</li> <li>fronzenset: Similar to set, frozensets are immutable and represent an unordered collection of unique elements. While elements of a set can be modified at any time, elements of the frozen set remain the same after creation.</li> </ul> set.py<pre><code>&gt;&gt;&gt; my_set = set((\"apple\", \"banana\", \"cherry\"))\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; my_set = {5, 6, 7, 8}\n&gt;&gt;&gt; print(my_set)\n&gt;&gt;&gt; print(type(my_set))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_frozenset = frozenset([1, 2, 3, 4, 5])\n&gt;&gt;&gt; print(my_frozenset)\n&gt;&gt;&gt; print(type(my_frozenset))\n{'cherry', 'banana', 'apple'}\n&lt;class 'set'&gt;\n{8, 5, 6, 7}\n&lt;class 'set'&gt;\n---------------------------&gt;\nfrozenset({1, 2, 3, 4, 5})\n&lt;class 'frozenset'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#boolean-type","title":"Boolean Type","text":"<ul> <li>boll: Represents a logical value indicating either True or False. Boolean values are often the result of comparisons or logical operations.</li> </ul> bool.py<pre><code>&gt;&gt;&gt; my_bool = bool(5)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = bool(0)\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\n&gt;&gt;&gt; my_bool = True\n&gt;&gt;&gt; print(my_bool)\n&gt;&gt;&gt; print(type(my_bool))\nTrue\n&lt;class 'bool'&gt;\nFalse\n&lt;class 'bool'&gt;\nTrue\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#binary-types","title":"Binary Types","text":"<ul> <li>bytes: Bytes are immutable sequences of individual bytes. They represent a fixed sequence of bytes that cannot be modified once created. Bytes can be created using literals or by calling the built-in bytes() constructor. They are commonly used to store and process raw binary data.</li> <li>bytearray: Bytearray, unlike bytes, is a mutable sequence of bytes. It allows modifications after creation, such as appending, replacing, or deleting elements. Bytearray objects can be created using literals or by calling the bytearray() constructor. They provide a flexible way to modify binary data.</li> <li>memoryview: Memoryview is a Python object that provides a way to access the internal data of an object (such as bytes or bytearray) without making a copy. It acts as a \"window\" into the data, allowing efficient access and manipulation of large amounts of binary data. Memoryview objects can be created by calling the built-in memoryview() constructor.</li> </ul> binary.py<pre><code>&gt;&gt;&gt; my_bytes = b\"Hello\"\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; my_bytes = bytes(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = bytearray(5)\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\n&gt;&gt;&gt; my_bytes = memoryview(bytes(5))\n&gt;&gt;&gt; print(my_bytes)\n&gt;&gt;&gt; print(type(my_bytes))\n&gt;&gt;&gt; print(\"---------------------------&gt;\")\nb'Hello'\n&lt;class 'bytes'&gt;\nb'\\x00\\x00\\x00\\x00\\x00'\n&lt;class 'bytes'&gt;\n---------------------------&gt;\nbytearray(b'\\x00\\x00\\x00\\x00\\x00')\n&lt;class 'bytearray'&gt;\n---------------------------&gt;\n&lt;memory at 0x7f5bc9c33f40&gt;\n&lt;class 'memoryview'&gt;\n---------------------------&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#none-type","title":"None Type","text":"<ul> <li>None: Represents a special value indicating the absence of a value. It is commonly used to denote a variable that has not been assigned a value.</li> </ul> none.py<pre><code>&gt;&gt;&gt; my_none = None\n&gt;&gt;&gt; print(my_none)\n&gt;&gt;&gt; print(type(my_none))\nNone\n&lt;class 'NoneType'&gt;\n</code></pre>"},{"location":"basics/variables_and_datatypes/#references","title":"References","text":"<ul> <li>W3Schools - Python Data Types</li> </ul>"},{"location":"data_model/","title":"Data Model","text":""}]}